*** ./config_office/configure.in.osr6	Wed Oct  5 03:19:55 2005
--- ./config_office/configure.in	Thu Oct 27 00:43:34 2005
***************
*** 620,625 ****
--- 620,632 ----
        			AC_MSG_ERROR([only sparc and i386 processors are supported])
     		fi
  		;;
+ 	sysv5* | SCO_SV)
+ 		test_x=yes
+ 		test_gtk=yes
+ 		test_kde=yes
+ 		test_cups=yes
+ 		_os=SCO_SV
+ 		;;
  	linux-gnu)
  		test_x=yes
  		test_gtk=yes
***************
*** 1364,1370 ****
  fi
  AC_SUBST(PAM_LINK)
  
! if test "$_os" = "Linux"; then
      AC_MSG_CHECKING([whether to link to libcrypt])
      if test -n "$enable_crypt_link"; then
          AC_MSG_RESULT([yes])
--- 1371,1377 ----
  fi
  AC_SUBST(PAM_LINK)
  
! if test "$_os" = "Linux" -o "$_os" = "SCO_SV"; then
      AC_MSG_CHECKING([whether to link to libcrypt])
      if test -n "$enable_crypt_link"; then
          AC_MSG_RESULT([yes])
***************
*** 1661,1667 ****
  dnl Checks for SGI STL
  dnl ===================================================================
  if test -n "$enable_sgistl" && "$enable_sgistl" != "no"; then
! 	if test "$_os" = "IRIX" -o "$_os" = "IRIX64"; then
  		AC_MSG_CHECKING([for SGI STL])
  		if test -d /usr/include/CC ; then
  			AC_MSG_RESULT([yes.])
--- 1668,1674 ----
  dnl Checks for SGI STL
  dnl ===================================================================
  if test -n "$enable_sgistl" && "$enable_sgistl" != "no"; then
! 	if test "$_os" = "IRIX" -o "$_os"="UnixWare" -o "$_os"="SCO_SV" -o "$_os" = "IRIX64"; then
  		AC_MSG_CHECKING([for SGI STL])
  		if test -d /usr/include/CC ; then
  			AC_MSG_RESULT([yes.])
***************
*** 1711,1728 ****
  		      else
  			      AC_MSG_ERROR([STLport4 libraries not found])
  		      fi
! 	      elif test "$_os" = "IRIX" -o "$_os" = "IRIX64"; then
  		      if test -f "$STLPORT4/lib/libstlport_mipspro_41.so"; then
  			      AC_MSG_RESULT([checked])
  			   else
! 				   if test -f "$STLPORT4/lib/libstlport_gcc.so"; then
  					   AC_MSG_RESULT([checked])
  				   else
  					   AC_MSG_ERROR([STLport4 libraries not found])
  				   fi
  			   fi
  		   else
! 			   if test -f "$STLPORT4/lib/libstlport_gcc.so"; then
  				   AC_MSG_RESULT([checked])
  			   else
  				   AC_MSG_ERROR([STLport4 libraries not found])
--- 1718,1735 ----
  		      else
  			      AC_MSG_ERROR([STLport4 libraries not found])
  		      fi
! 	      elif test "$_os" = "IRIX" -o "$_os"="UnixWare" -o "$_os"="SCO_SV" -o "$_os" = "IRIX64"; then
  		      if test -f "$STLPORT4/lib/libstlport_mipspro_41.so"; then
  			      AC_MSG_RESULT([checked])
  			   else
! 				   if test -f "$STLPORT4/lib/libstlport_sysv5.so"; then
  					   AC_MSG_RESULT([checked])
  				   else
  					   AC_MSG_ERROR([STLport4 libraries not found])
  				   fi
  			   fi
  		   else
! 			   if test -f "$STLPORT4/lib/libstlport_sysv5.so"; then
  				   AC_MSG_RESULT([checked])
  			   else
  				   AC_MSG_ERROR([STLport4 libraries not found])
***************
*** 2066,2076 ****
  dnl Checks for programs.
  dnl ===================================================================
  dnl Check whether there's a C pre-processor.
! if test "$_os" = "Linux" -o "$_os" = "FreeBSD" -o "$_os" = "NetBSD" ; then
     AC_PROG_CPP
  fi
  dnl Check whether there's a C++ pre-processor.
! if test "$_os" = "Linux" -o "$_os" = "FreeBSD" -o "$_os" = "NetBSD" ; then
     AC_PROG_CXXCPP
  fi
  
--- 2073,2083 ----
  dnl Checks for programs.
  dnl ===================================================================
  dnl Check whether there's a C pre-processor.
! if test "$_os" = "Linux" -o "$_os" = "SCO_SV" -o "$_os" = "FreeBSD" -o "$_os" = "NetBSD" ; then
     AC_PROG_CPP
  fi
  dnl Check whether there's a C++ pre-processor.
! if test "$_os" = "Linux" -o "$_os" = "SCO_SV" -o "$_os" = "FreeBSD" -o "$_os" = "NetBSD" ; then
     AC_PROG_CXXCPP
  fi
  
***************
*** 2227,2232 ****
--- 2234,2242 ----
  	Darwin)
  		PKGFORMAT=portable
  		;;
+ 	SCO_SV)
+ 		PKGFORMAT=native
+ 		;;
  	SunOS)
  		PKGFORMAT=pkg
  		;;
***************
*** 3090,3096 ****
          ], []
      )
      AC_CHECK_LIB(audio, AuOpenServer, [],
!         [AC_MSG_ERROR(nas not found or functional)], [-L$XLIB -lXt])
      ENABLE_NAS=YES
  else
      AC_MSG_RESULT([internal])
--- 3100,3106 ----
          ], []
      )
      AC_CHECK_LIB(audio, AuOpenServer, [],
!         [AC_MSG_ERROR(nas not found or functional)], [-L$XLIB -lXt -lm])
      ENABLE_NAS=YES
  else
      AC_MSG_RESULT([internal])
***************
*** 3441,3447 ****
  fi
  
  dnl On Solaris, FreeBSD or MacOS X, check if --with-gnu-patch was used
! if test "$_os" = "SunOS" -o "$_os" = "FreeBSD" -o "$_os" = "Darwin"; then
     if test -z "$with_gnu_patch"; then
        GNUPATCH=$PATCH
     else
--- 3451,3457 ----
  fi
  
  dnl On Solaris, FreeBSD or MacOS X, check if --with-gnu-patch was used
! if test "$_os" = "SunOS" -o "$_os" = "FreeBSD" -o "$_os" = "UnixWare" -o "$_os" = "SCO_SV" -o "$_os" = "Darwin"; then
     if test -z "$with_gnu_patch"; then
        GNUPATCH=$PATCH
     else
***************
*** 3987,3993 ****
     USE_XINERAMA=YES
     XINERAMA_LINK=dynamic
     AC_MSG_RESULT([yes])
! elif test "$_os" = "Linux" -o "$_os" = "FreeBSD"; then
     if test -e "$XLIB/libXinerama.so" -a -e "$XLIB/libXinerama.a"; then
        # we have both versions, let the user decide but use the static one
        # per default
--- 3997,4003 ----
     USE_XINERAMA=YES
     XINERAMA_LINK=dynamic
     AC_MSG_RESULT([yes])
! elif test "$_os" = "Linux" -o "$_os" = "SCO_SV" -o "$_os" = "FreeBSD"; then
     if test -e "$XLIB/libXinerama.so" -a -e "$XLIB/libXinerama.a"; then
        # we have both versions, let the user decide but use the static one
        # per default
***************
*** 4020,4027 ****
        AC_CHECK_HEADER(X11/extensions/Xinerama.h, [],
            [AC_MSG_ERROR(Xinerama header not found.)], [])
        XINERAMA_EXTRA_LIBS="-L$XLIB -lXext"
!       if test "$_os" = "FreeBSD"; then
!   	XINERAMA_EXTRA_LIBS="$XINERAMA_EXTRA_LIBS -lXt"
        fi
        AC_CHECK_LIB(Xinerama, XineramaIsActive, [],
            [AC_MSG_ERROR(Xinerama not functional?)], [$XINERAMA_EXTRA_LIBS])
--- 4030,4037 ----
        AC_CHECK_HEADER(X11/extensions/Xinerama.h, [],
            [AC_MSG_ERROR(Xinerama header not found.)], [])
        XINERAMA_EXTRA_LIBS="-L$XLIB -lXext"
!       if test "$_os" = "FreeBSD" -o "$_os" = "SCO_SV"; then
!   	XINERAMA_EXTRA_LIBS="$XINERAMA_EXTRA_LIBS -lXt -lm"
        fi
        AC_CHECK_LIB(Xinerama, XineramaIsActive, [],
            [AC_MSG_ERROR(Xinerama not functional?)], [$XINERAMA_EXTRA_LIBS])
*** ./config_office/set_soenv.in.osr6	Thu Sep 22 07:30:56 2005
--- ./config_office/set_soenv.in	Wed Oct 26 20:22:51 2005
***************
*** 38,47 ****
  # IIa. Declaring variables for the system commands, etc.
  #--------------------------------------------------------
  #
! my ( $outfile, $outfile_sh, $outfile_bat, $bootfile, $newline, $comment, $comment4nt, $compiler, $unsetenv, $setenv, $unset, $set, $ds, $ps, $cur_dir, 
!      $par_dir, $I, $L, $D, $buildenv, $answer, $tmp, $MINGW, $platform,
!      $cygwinver, $empty, $no_ant, $no_stl, $no_gcc_include, 
!      $no_gxx_include, $warnfile, $Warning, $result, $unsetvars, $unsetvarssh, $unsetvarsbat, $exportvars, $win_format_var, $perl_os);
  #
  #-------------------------------------------------
  # IIb. Declaring environment values (constants).
--- 38,49 ----
  # IIa. Declaring variables for the system commands, etc.
  #--------------------------------------------------------
  #
! my ( $outfile, $outfile_sh, $outfile_bat, $bootfile, $newline, $comment, 
!      $comment4nt, $compiler, $unsetenv, $setenv, $unset, $set, $ds, $ps,
!      $cur_dir, $par_dir, $I, $L, $D, $buildenv, $answer, $tmp, $MINGW,
!      $platform, $cygwinver, $empty, $no_ant, $no_stl, $no_gcc_include, 
!      $no_gxx_include, $warnfile, $Warning, $result, $unsetvars, 
!      $unsetvarssh, $unsetvarsbat, $exportvars, $win_format_var, $perl_os);
  #
  #-------------------------------------------------
  # IIb. Declaring environment values (constants).
***************
*** 266,271 ****
--- 268,299 ----
     $OS             = "SOLARIS";
     $PATH_SEPERATOR = $ps;
  }
+ elsif ( $platform =~ m/sysv5*/ ) 
+ {     print "Setting OpenServer 6 specific values... ";
+    if ($platform =~ m/^i[3456]86/)
+    {  $outfile        = "UnixIntelEnv.Set";
+       $CPU            = "I";
+       $CPUNAME        = "INTEL";
+       $DLLSUFFIX      = "ci";
+       $OUTPATH        = "unxscoudk";
+       $COMEX          = 4;
+       $JRELIBDIR      = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."i386";
+       $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."i386".$ds."motif12".$ps.'$JAVA_HOME'.$ds."jre".$ds."lib".$ds."i386".$ds."server";
+       $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."i386".$ds."native_threads";
+    }
+    $BIG_SVX        = "TRUE";
+    $COM            = "UDK";
+    $COMPATH        = '@COMPATH@';
+    $CVER           = "U420";
+    $GUI            = "UNX";
+    $GUIBASE        = "unx";
+    $GUIENV         = "sal";
+    $GVER           = "VCL";
+    $INPATH         = $OUTPATH.$PROEXT;
+    $GVERDIR        = $INPATH;
+    $OS             = "SCO";
+    $PATH_SEPERATOR = $ps;
+ }
  elsif ( $platform =~ m/netbsd/ ) 
  {
  #Set platform specific values: 
***************
*** 910,915 ****
--- 938,952 ----
                          $ps.$JRETHREADDIR.
                          $ps.'$SOLARVER'.$ds.'$UPD'.$ds.'$INPATH'.$LIB;
  }
+ elsif ($platform =~ m/sysv5*/)
+ {  $LD_LIBRARY_PATH   = $cur_dir.
+                         $ps.$par_dir.$LIB.
+                         $ps_STLPORT_LIB.
+                         $ps.$JRELIBDIR.
+                         $ps.$JRETOOLKITDIR.
+                         $ps.$JRETHREADDIR.
+                         $ps.'$SOLARVER'.$ds.'$UPD'.$ds.'$INPATH'.$LIB;
+ }
  elsif ($platform =~ m/linux-gnu|netbsd|osf1|freebsd|aix/)
  {  $LD_LIBRARY_PATH   = $cur_dir.
                          $ps.'$SOLARENV'.$ds.'$INPATH'.$LIB.
***************
*** 957,962 ****
--- 994,1016 ----
                          $D."SUPD=$UPD".
                          $D."UPDVER=".'""'."'".'"'."'".'"'."SV$UPD".'"'."'".'"'."'".'"'.'"';
  }
+ elsif ($platform =~ m/sysv5*/)
+ {  $SOLARDEF          = $D."UNX".
+                         $D.$COM.
+                         $D.$GVER.
+                         $D."_PTHREADS".
+                         $D."NO_AUDIO".
+                         $D."SYSV".
+                         $D.$OS.
+                         $D.$CPUNAME.
+                         $D."SUN".
+                         $D."SUN4".
+                         $D."_REENTRANT".
+                         $D."_POSIX_PTHREAD_SEMANTICS".
+                         $D."SUPD=$UPD".
+                         $D."PRODUCT".
+                         $D."UPDVER=".'""'."'".'"'."'".'"'."SV$UPD".'"'."'".'"'."'".'"'.'"';
+ }
  elsif ($platform =~ m/linux-gnu|netbsd|freebsd|osf1|irix|aix/)
  {  $SOLARDEF          = $D."UNX".
                          $D.$COM.
***************
*** 994,999 ****
--- 1048,1062 ----
                          $L.$USR_DT.$LIB.
                          $L.$USR_OPENWIN.$LIB;
  }
+ elsif ($platform =~ m/sysv5*/)
+ {  $SOLAREXTRALIB     = $L.$par_dir.$LIB.
+                         $L.$LIB.
+                         $L.$USR.'/gnu/lib'.
+                         $L.$USR.'/X11R6/lib'.
+                         $L.$USR.$LIB.
+                         $L.$USR.$LOCAL.$LIB.
+                         $L.$par_dir.$LIB;
+ }
  elsif ($platform =~ m/linux-gnu|netbsd|osf1|irix|freebsd|aix/)
  {
     $SOLAREXTRALIB     = $L.$par_dir.$LIB64;
***************
*** 1035,1041 ****
  }
       
  # The general environment path.
! if ($platform =~ m/linux-gnu|netbsd|odf1|irix|freebsd|aix|solaris/)
  {  $PATH              = $cur_dir.
                          $ps.'$SOLARVER'.$ds.'$UPD'.$ds.'$INPATH'.$BIN.
                          $ps.'$SOLARENV'.$ds.'$OUTPATH'.$BIN.
--- 1098,1104 ----
  }
       
  # The general environment path.
! if ($platform =~ m/linux-gnu|netbsd|odf1|irix|freebsd|aix|sysv5*|solaris/)
  {  $PATH              = $cur_dir.
                          $ps.'$SOLARVER'.$ds.'$UPD'.$ds.'$INPATH'.$BIN.
                          $ps.'$SOLARENV'.$ds.'$OUTPATH'.$BIN.
***************
*** 1201,1209 ****
                          $L.$LIB.
                          $L.$USR_LIB;
     if ( $CC =~ "gcc" ) {
!       my $temp = $COMPATH;
!       $temp =~ s:/bin$::;
!       $SOLARLIB      .= $L.$temp.$LIB;
     }
     $SOLARLIB         .= $L.$USR_LOCAL.$LIB.
                          $L.$USR_DT.$LIB.
--- 1264,1272 ----
                          $L.$LIB.
                          $L.$USR_LIB;
     if ( $CC =~ "gcc" ) {
!       my $ctemp = $COMPATH;
!       $ctemp =~ s:/bin$::;
!       $SOLARLIB      .= $L.$ctemp.$LIB;
     }
     $SOLARLIB         .= $L.$USR_LOCAL.$LIB.
                          $L.$USR_DT.$LIB.
***************
*** 1215,1220 ****
--- 1278,1298 ----
                          $L_STLPORT_LIB.
                          $L.$XLIB;
  }
+ elsif ($platform =~ m/sysv5*/)
+ {  $SOLARLIB          = $L.$par_dir.$LIB.
+                         $L.'$SOLARENV'.$ds.'$OUTPATH'.$LIB.
+                         $L.'$SOLARVER'.$ds.'$UPD'.$ds.'$INPATH'.$LIB.
+                         $L.'$SOLARENV'.$ds.'$OUTPATH'.$LIB.
+                         $L.$LIB.
+                         $L.$USR_LIB.
+                         $L.$USR_LOCAL.$LIB.
+                         $L.'$JAVA_HOME'.$LIB.
+                         $L.$JRELIBDIR.
+                         $L.$JRETOOLKITDIR.
+                         $L.$JRETHREADDIR.
+                         $L_STLPORT_LIB.
+                         $L.$XLIB;
+ }
  elsif ($platform =~ m/linux-gnu|netbasd|osf1|irix|aix|freebsd/)
  {  $SOLARLIB          = $L.$par_dir.$LIB.
                          $L.'$SOLARENV'.$ds.'$OUTPATH'.$LIB.
***************
*** 1258,1264 ****
                          $I.'$SOLARENV'.$INC.
                          $I.'$SRC_ROOT'.$ds."res";
  
! if ($platform =~ m/solaris|linux-gnu|osf1|freebsd|netbsd|irix/)
  {
  $SOLARINC	     .= $STLPORT_stlport;
  if ($platform =~ m/linux|freebsd|netbsd/)
--- 1336,1342 ----
                          $I.'$SOLARENV'.$INC.
                          $I.'$SRC_ROOT'.$ds."res";
  
! if ($platform =~ m/solaris|sysv5*|linux-gnu|osf1|freebsd|netbsd|irix/)
  {
  $SOLARINC	     .= $STLPORT_stlport;
  if ($platform =~ m/linux|freebsd|netbsd/)
***************
*** 1270,1275 ****
--- 1348,1357 ----
  {
  $SOLARINC            .= '/SC5 ';
  }
+ if ($platform =~ m/sysv5*/)
+ {
+ $SOLARINC            .= $I.$SRC_ROOT.$ds.'stl'.$I.$USR.$LIB.'/apache/include/xml'.$I.$USR.$LIB.'/apache/include';
+ }
  # Platform dependent include path at the top of this list of include paths
  if ($platform =~ m/solaris/)
  {   my $temp;
***************
*** 1292,1297 ****
--- 1374,1382 ----
     		if ($platform =~ m/solaris/)
     		{  $SOLARINC   .=$I.'$JAVA_HOME'.$INCLUDE.$ds."solaris";
     		}
+    		elsif  ($platform =~ m/sysv5*/)
+ 		{  $SOLARINC .=$I.'$JAVA_HOME'.$INCLUDE.$ds."unixware".$I.$USR.$INCLUDE.'/openssl';
+ 		}
     		elsif  ($platform =~ m/linux-gnu|osf1/)
     		{  $SOLARINC   .=$I.'$JAVA_HOME'.$INCLUDE.$ds."linux";
     		}
***************
*** 1439,1446 ****
  {	
     foreach $dict (@DICTIONARIES)
     {   if ('@WITH_DICT@' =~ m/$dict,/s)
!        {   my $val="TRUE";
!            ToFile( "DIC_$dict",     $val,          "e" );
         }
         else
         {   my $val;
--- 1524,1531 ----
  {	
     foreach $dict (@DICTIONARIES)
     {   if ('@WITH_DICT@' =~ m/$dict,/s)
!        {   my $val1="TRUE";
!            ToFile( "DIC_$dict",     $val1,          "e" );
         }
         else
         {   my $val;
***************
*** 1849,1855 ****
    ToFile( "  ", $empty, "x");
  }
  # on Solaris, MacOSX and FreeBSD, set GNUCOPY and GNUPATCH
! if ($platform =~ m/solaris|darwin|freebsd/)
  {
    ToFile( "GNUPATCH",   "@GNUPATCH@",	"e");
    ToFile( "GNUCOPY",	"@GNUCP@",	"e");
--- 1934,1940 ----
    ToFile( "  ", $empty, "x");
  }
  # on Solaris, MacOSX and FreeBSD, set GNUCOPY and GNUPATCH
! if ($platform =~ m/solaris|sysv5*|darwin|freebsd/)
  {
    ToFile( "GNUPATCH",   "@GNUPATCH@",	"e");
    ToFile( "GNUCOPY",	"@GNUCP@",	"e");
*** ./config_office/bootstrap.1.osr6	Wed Dec 17 07:00:10 2003
--- ./config_office/bootstrap.1	Wed Oct 26 20:22:51 2005
***************
*** 30,35 ****
--- 30,36 ----
      if "$?" != "0" exit $?
    endif
  
+   [ -x /usr/gnu/bin/autoconf ] && /usr/gnu/bin/autoconf
    ./configure
    if "$?" != "0" exit $?
  
*** ./cosv/prj/build.lst.osr6	Mon Jun 10 04:46:25 2002
--- ./cosv/prj/build.lst	Thu Oct 27 00:48:49 2005
***************
*** 1,5 ****
  #====================================================================================
! cs	cosv	:  soltools stlport NULL
  cs	cosv								usr1	-	all	cs_mkout NULL
  cs	cosv\prj							get		-	all	cs_prj NULL
  cs	cosv\inc							get		-	all	cs_inc NULL
--- 1,5 ----
  #====================================================================================
! cs	cosv	:  soltools NULL
  cs	cosv								usr1	-	all	cs_mkout NULL
  cs	cosv\prj							get		-	all	cs_prj NULL
  cs	cosv\inc							get		-	all	cs_inc NULL
*** ./dmake/configure.in.osr6	Fri Oct 22 01:04:28 2004
--- ./dmake/configure.in	Wed Oct 26 20:22:51 2005
***************
*** 84,89 ****
--- 84,92 ----
  	"SunOS")
  	  OS_VERSION=solaris  
  	  ;;
+ 	"SCO_SV" | "UnixWare")
+ 	  OS_VERSION=linux
+ 	  ;;
  	"Linux")
  	  OS_VERSION=linux
  	  ;;
*** ./extensions/prj/build.lst.osr6	Mon Jun 20 08:02:49 2005
--- ./extensions/prj/build.lst	Wed Oct 26 20:22:51 2005
***************
*** 1,4 ****
! ex	extensions	:	rdbmaker svx SANE:sane twain offuh np_sdk stoc uui NULL
  ex	extensions					usr1	-	all	ex_mkout NULL
  ex	extensions\inc					get		-	all	ex_inc NULL
  ex	extensions\inc\ucbhelper			get		-	all	ex_incucbh NULL
--- 1,4 ----
! ex	extensions	:	rdbmaker svx SANE:sane twain offuh stoc uui NULL
  ex	extensions					usr1	-	all	ex_mkout NULL
  ex	extensions\inc					get		-	all	ex_inc NULL
  ex	extensions\inc\ucbhelper			get		-	all	ex_incucbh NULL
*** ./external/gpc/VERSIONS.TXT.osr6	Wed Oct 26 20:22:51 2005
--- ./external/gpc/VERSIONS.TXT	Wed Oct 26 20:22:51 2005
***************
*** 0 ****
--- 1,123 ----
+ 
+ Generic Polygon Clipper (gpc) Revision History
+ ==============================================
+ 
+ 
+ v2.32   17th Dec 2004
+ ---------------------
+     Fixed occasional memory leak occurring when processing some
+     degenerate polygon arrangements.
+     Added explicit type casting to memory allocator in support of
+     increased code portability.
+ 
+ v2.31    4th Jun 1999
+ ---------------------
+     Separated edge merging measure based on a user-defined GPC_EPSILON
+     value from general numeric equality testing and ordering, which now
+     uses direct arithmetic comparison rather an EPSILON based proximity
+     test.
+     Fixed problem with numerical equality test during construction of
+     local minima and scanbeam tables, leading to occasional crash.
+     Fixed hole array memory leak in gpc_add_contour.
+     Fixed uninitialised hole field bug in gpc_polygon_clip result.
+ 
+ v2.30   11th Apr 1999
+ ---------------------
+     Major re-write.
+     Minor API change: additional 'hole' array field added to gpc_polygon
+     datatype to indicate which constituent contours are internal holes,
+     and which form external boundaries.
+     Minor API change: additional 'hole' argument to gpc_add_contour
+     to indicate whether the new contour is a hole or external contour.
+     Minor API change: additional parameter to gpc_read_polygon and
+     gpc_write_polygon to indicate whether or not to read or write
+     contour hole flags.
+     Fixed NULL pointer bug in add/merge left/right operations.
+     Fixed numerical problem in intersection table generation.
+     Fixed zero byte malloc problem.
+     Fixed problem producing occasional 2 vertex contours.
+     Added bounding box test optimisations.
+     Simplified edge bundle creation, detection of scanbeam internal
+     edge intersections and tristrip scanbeam boundary code.
+     Renamed 'class' variable to be C++ friendly.
+ 
+ v2.22   17th Oct 1998
+ ---------------------
+     Re-implemented edge interpolation and intersection calculations
+     to improve numerical robustness.
+     Simplified setting of GPC_EPSILON.
+ 
+ v2.21   19th Aug 1998
+ ---------------------
+     Fixed problem causing occasional incorrect output when processing
+     self-intersecting polygons (bow-ties etc).
+     Removed bug which may lead to non-generation of uppermost triangle
+     in tristrip output.
+ 
+ v2.20   26th May 1998
+ ---------------------
+     Major re-write.
+     Added exclusive-or polygon set operation.
+     Replaced table-based processing of edge intersections with
+     rule-based system.
+     Replaced two-pass approach to scanbeam interior processing with
+     single pass method.
+ 
+ v2.10a  14th May 1998
+ ---------------------
+     Minor bug-fixes to counter some v2.10 reliability problems.
+ 
+ v2.10   11th May 1998
+ ---------------------
+     Major re-write.
+     Incorporated edge bundle processing of AET to overcome coincident
+     edge problems present in previous releases.
+     Replaced Vatti's method for processing scanbeam interior regions
+     with an adapted version of the scanbeam boundary processing
+     algorithm.
+ 
+ v2.02   16th Apr 1998 (unreleased)
+ ----------------------------------
+     Fixed internal minimum vertex duplication in gpc_polygon_clip
+     result.
+     Improved line intersection code discourage superfluous
+     intersections near line ends. 
+     Removed limited precision number formatting in gpc_write_polygon.
+     Modification to allow subject or clip polygon to be reused as the
+     result in gpc_polygon_clip without memory leakage.
+ 
+ v2.01   23rd Feb 1998
+ ---------------------
+     Removed bug causing duplicated vertices in output polygon.
+     Fixed scanbeam table index overrun problem.
+ 
+ v2.00   25th Nov 1997
+ ---------------------
+     Major re-write.
+     Replaced temporary horizontal edge work-around (using tilting)
+     with true horizontal edge handling.
+     Trapezoidal output replaced by tristrips.
+     gpc_op constants now feature a `GPC_' prefix.
+     Data structures now passed by reference to gpc functions.
+     Replaced AET search by proxy addressing in polygon table.
+     Eliminated most (all?) coincident vertex / edge crashes.
+ 
+ v1.02   18th Oct 1997 (unreleased)
+ ----------------------------------
+     Significantly reduced number of mallocs in build_lmt. 
+     Scanbeam table now built using heapsort rather than insertion
+     sort.
+    
+ v1.01   12th Oct 1997
+ ---------------------
+     Fixed memory leak during output polygon build in
+     gpc_clip_polygon.
+     Removed superfluous logfile debug code.
+     Commented out malloc counts.
+     Added missing horizontal edge tilt-correction code in
+     gpc_clip_polygon.
+    
+ v1.00   8th Oct 1997
+ --------------------
+     First release.
+ 
*** ./external/gpc/gpc.c.osr6	Wed Oct 26 20:22:51 2005
--- ./external/gpc/gpc.c	Wed Oct 26 20:22:51 2005
***************
*** 0 ****
--- 1,2472 ----
+ /*
+ ===========================================================================
+ 
+ Project:   Generic Polygon Clipper
+ 
+            A new algorithm for calculating the difference, intersection,
+            exclusive-or or union of arbitrary polygon sets.
+ 
+ File:      gpc.c
+ Author:    Alan Murta (email: gpc@cs.man.ac.uk)
+ Version:   2.32
+ Date:      17th December 2004
+ 
+ Copyright: (C) 1997-2004, Advanced Interfaces Group,
+            University of Manchester.
+ 
+            This software is free for non-commercial use. It may be copied,
+            modified, and redistributed provided that this copyright notice
+            is preserved on all copies. The intellectual property rights of
+            the algorithms used reside with the University of Manchester
+            Advanced Interfaces Group.
+ 
+            You may not use this software, in whole or in part, in support
+            of any commercial product without the express consent of the
+            author.
+ 
+            There is no warranty or other guarantee of fitness of this
+            software for any purpose. It is provided solely "as is".
+ 
+ ===========================================================================
+ */
+ 
+ 
+ /*
+ ===========================================================================
+                                 Includes
+ ===========================================================================
+ */
+ 
+ #include "gpc.h"
+ #include <stdlib.h>
+ #include <float.h>
+ #include <math.h>
+ 
+ 
+ /*
+ ===========================================================================
+                                 Constants
+ ===========================================================================
+ */
+ 
+ #ifndef TRUE
+ #define FALSE              0
+ #define TRUE               1
+ #endif
+ 
+ #define LEFT               0
+ #define RIGHT              1
+ 
+ #define ABOVE              0
+ #define BELOW              1
+ 
+ #define CLIP               0
+ #define SUBJ               1
+ 
+ #define INVERT_TRISTRIPS   FALSE
+ 
+ 
+ /*
+ ===========================================================================
+                                  Macros 
+ ===========================================================================
+ */
+ 
+ #define EQ(a, b)           (fabs((a) - (b)) <= GPC_EPSILON)
+ 
+ #define PREV_INDEX(i, n)   ((i - 1 + n) % n)
+ #define NEXT_INDEX(i, n)   ((i + 1    ) % n)
+ 
+ #define OPTIMAL(v, i, n)   ((v[PREV_INDEX(i, n)].y != v[i].y) || \
+                             (v[NEXT_INDEX(i, n)].y != v[i].y))
+ 
+ #define FWD_MIN(v, i, n)   ((v[PREV_INDEX(i, n)].vertex.y >= v[i].vertex.y) \
+                          && (v[NEXT_INDEX(i, n)].vertex.y > v[i].vertex.y))
+ 
+ #define NOT_FMAX(v, i, n)   (v[NEXT_INDEX(i, n)].vertex.y > v[i].vertex.y)
+ 
+ #define REV_MIN(v, i, n)   ((v[PREV_INDEX(i, n)].vertex.y > v[i].vertex.y) \
+                          && (v[NEXT_INDEX(i, n)].vertex.y >= v[i].vertex.y))
+ 
+ #define NOT_RMAX(v, i, n)   (v[PREV_INDEX(i, n)].vertex.y > v[i].vertex.y)
+ 
+ #define VERTEX(e,p,s,x,y)  {add_vertex(&((e)->outp[(p)]->v[(s)]), x, y); \
+                             (e)->outp[(p)]->active++;}
+ 
+ #define P_EDGE(d,e,p,i,j)  {(d)= (e); \
+                             do {(d)= (d)->prev;} while (!(d)->outp[(p)]); \
+                             (i)= (d)->bot.x + (d)->dx * ((j)-(d)->bot.y);}
+ 
+ #define N_EDGE(d,e,p,i,j)  {(d)= (e); \
+                             do {(d)= (d)->next;} while (!(d)->outp[(p)]); \
+                             (i)= (d)->bot.x + (d)->dx * ((j)-(d)->bot.y);}
+ 
+ #define MALLOC(p, b, s, t) {if ((b) > 0) { \
+                             p= (t*)malloc(b); if (!(p)) { \
+                             fprintf(stderr, "gpc malloc failure: %s\n", s); \
+                             exit(0);}} else p= NULL;}
+ 
+ #define FREE(p)            {if (p) {free(p); (p)= NULL;}}
+ 
+ 
+ /*
+ ===========================================================================
+                             Private Data Types
+ ===========================================================================
+ */
+ 
+ typedef enum                        /* Edge intersection classes         */
+ {
+   NUL,                              /* Empty non-intersection            */
+   EMX,                              /* External maximum                  */
+   ELI,                              /* External left intermediate        */
+   TED,                              /* Top edge                          */
+   ERI,                              /* External right intermediate       */
+   RED,                              /* Right edge                        */
+   IMM,                              /* Internal maximum and minimum      */
+   IMN,                              /* Internal minimum                  */
+   EMN,                              /* External minimum                  */
+   EMM,                              /* External maximum and minimum      */
+   LED,                              /* Left edge                         */
+   ILI,                              /* Internal left intermediate        */
+   BED,                              /* Bottom edge                       */
+   IRI,                              /* Internal right intermediate       */
+   IMX,                              /* Internal maximum                  */
+   FUL                               /* Full non-intersection             */
+ } vertex_type;
+ 
+ typedef enum                        /* Horizontal edge states            */
+ {
+   NH,                               /* No horizontal edge                */
+   BH,                               /* Bottom horizontal edge            */
+   TH                                /* Top horizontal edge               */
+ } h_state;
+ 
+ typedef enum                        /* Edge bundle state                 */
+ {
+   UNBUNDLED,                        /* Isolated edge not within a bundle */
+   BUNDLE_HEAD,                      /* Bundle head node                  */
+   BUNDLE_TAIL                       /* Passive bundle tail node          */
+ } bundle_state;
+ 
+ typedef struct v_shape              /* Internal vertex list datatype     */
+ {
+   double              x;            /* X coordinate component            */
+   double              y;            /* Y coordinate component            */
+   struct v_shape     *next;         /* Pointer to next vertex in list    */
+ } vertex_node;
+ 
+ typedef struct p_shape              /* Internal contour / tristrip type  */
+ {
+   int                 active;       /* Active flag / vertex count        */
+   int                 hole;         /* Hole / external contour flag      */
+   vertex_node        *v[2];         /* Left and right vertex list ptrs   */
+   struct p_shape     *next;         /* Pointer to next polygon contour   */
+   struct p_shape     *proxy;        /* Pointer to actual structure used  */
+ } polygon_node;
+ 
+ typedef struct edge_shape
+ {
+   gpc_vertex          vertex;       /* Piggy-backed contour vertex data  */
+   gpc_vertex          bot;          /* Edge lower (x, y) coordinate      */
+   gpc_vertex          top;          /* Edge upper (x, y) coordinate      */
+   double              xb;           /* Scanbeam bottom x coordinate      */
+   double              xt;           /* Scanbeam top x coordinate         */
+   double              dx;           /* Change in x for a unit y increase */
+   int                 type;         /* Clip / subject edge flag          */
+   int                 bundle[2][2]; /* Bundle edge flags                 */
+   int                 bside[2];     /* Bundle left / right indicators    */
+   bundle_state        bstate[2];    /* Edge bundle state                 */
+   polygon_node       *outp[2];      /* Output polygon / tristrip pointer */
+   struct edge_shape  *prev;         /* Previous edge in the AET          */
+   struct edge_shape  *next;         /* Next edge in the AET              */
+   struct edge_shape  *pred;         /* Edge connected at the lower end   */
+   struct edge_shape  *succ;         /* Edge connected at the upper end   */
+   struct edge_shape  *next_bound;   /* Pointer to next bound in LMT      */
+ } edge_node;
+ 
+ typedef struct lmt_shape            /* Local minima table                */
+ {
+   double              y;            /* Y coordinate at local minimum     */
+   edge_node          *first_bound;  /* Pointer to bound list             */
+   struct lmt_shape   *next;         /* Pointer to next local minimum     */
+ } lmt_node;
+ 
+ typedef struct sbt_t_shape          /* Scanbeam tree                     */
+ {
+   double              y;            /* Scanbeam node y value             */
+   struct sbt_t_shape *less;         /* Pointer to nodes with lower y     */
+   struct sbt_t_shape *more;         /* Pointer to nodes with higher y    */
+ } sb_tree;
+ 
+ typedef struct it_shape             /* Intersection table                */
+ {
+   edge_node          *ie[2];        /* Intersecting edge (bundle) pair   */
+   gpc_vertex          point;        /* Point of intersection             */
+   struct it_shape    *next;         /* The next intersection table node  */
+ } it_node;
+ 
+ typedef struct st_shape             /* Sorted edge table                 */
+ {
+   edge_node          *edge;         /* Pointer to AET edge               */
+   double              xb;           /* Scanbeam bottom x coordinate      */
+   double              xt;           /* Scanbeam top x coordinate         */
+   double              dx;           /* Change in x for a unit y increase */
+   struct st_shape    *prev;         /* Previous edge in sorted list      */
+ } st_node;
+ 
+ typedef struct bbox_shape           /* Contour axis-aligned bounding box */
+ {
+   double             xmin;          /* Minimum x coordinate              */
+   double             ymin;          /* Minimum y coordinate              */
+   double             xmax;          /* Maximum x coordinate              */
+   double             ymax;          /* Maximum y coordinate              */
+ } bbox;
+ 
+ 
+ /*
+ ===========================================================================
+                                Global Data
+ ===========================================================================
+ */
+ 
+ /* Horizontal edge state transitions within scanbeam boundary */
+ const h_state next_h_state[3][6]=
+ {
+   /*        ABOVE     BELOW     CROSS */
+   /*        L   R     L   R     L   R */  
+   /* NH */ {BH, TH,   TH, BH,   NH, NH},
+   /* BH */ {NH, NH,   NH, NH,   TH, TH},
+   /* TH */ {NH, NH,   NH, NH,   BH, BH}
+ };
+ 
+ 
+ /*
+ ===========================================================================
+                              Private Functions
+ ===========================================================================
+ */
+ 
+ static void reset_it(it_node **it)
+ {
+   it_node *itn;
+ 
+   while (*it)
+   {
+     itn= (*it)->next;
+     FREE(*it);
+     *it= itn;
+   }
+ }
+ 
+ 
+ static void reset_lmt(lmt_node **lmt)
+ {
+   lmt_node *lmtn;
+ 
+   while (*lmt)
+   {
+     lmtn= (*lmt)->next;
+     FREE(*lmt);
+     *lmt= lmtn;
+   }
+ }
+ 
+ 
+ static void insert_bound(edge_node **b, edge_node *e)
+ {
+   edge_node *existing_bound;
+ 
+   if (!*b)
+   {
+     /* Link node e to the tail of the list */
+     *b= e;
+   }
+   else
+   {
+     /* Do primary sort on the x field */
+     if (e[0].bot.x < (*b)[0].bot.x)
+     {
+       /* Insert a new node mid-list */
+       existing_bound= *b;
+       *b= e;
+       (*b)->next_bound= existing_bound;
+     }
+     else
+     {
+       if (e[0].bot.x == (*b)[0].bot.x)
+       {
+         /* Do secondary sort on the dx field */
+         if (e[0].dx < (*b)[0].dx)
+         {
+           /* Insert a new node mid-list */
+           existing_bound= *b;
+           *b= e;
+           (*b)->next_bound= existing_bound;
+         }
+         else
+         {
+           /* Head further down the list */
+           insert_bound(&((*b)->next_bound), e);
+         }
+       }
+       else
+       {
+         /* Head further down the list */
+         insert_bound(&((*b)->next_bound), e);
+       }
+     }
+   }
+ }
+ 
+ 
+ static edge_node **bound_list(lmt_node **lmt, double y)
+ {
+   lmt_node *existing_node;
+ 
+   if (!*lmt)
+   {
+     /* Add node onto the tail end of the LMT */
+     MALLOC(*lmt, sizeof(lmt_node), "LMT insertion", lmt_node);
+     (*lmt)->y= y;
+     (*lmt)->first_bound= NULL;
+     (*lmt)->next= NULL;
+     return &((*lmt)->first_bound);
+   }
+   else
+     if (y < (*lmt)->y)
+     {
+       /* Insert a new LMT node before the current node */
+       existing_node= *lmt;
+       MALLOC(*lmt, sizeof(lmt_node), "LMT insertion", lmt_node);
+       (*lmt)->y= y;
+       (*lmt)->first_bound= NULL;
+       (*lmt)->next= existing_node;
+       return &((*lmt)->first_bound);
+     }
+     else
+       if (y > (*lmt)->y)
+         /* Head further up the LMT */
+         return bound_list(&((*lmt)->next), y);
+       else
+         /* Use this existing LMT node */
+         return &((*lmt)->first_bound);
+ }
+ 
+ 
+ static void add_to_sbtree(int *entries, sb_tree **sbtree, double y)
+ {
+   if (!*sbtree)
+   {
+     /* Add a new tree node here */
+     MALLOC(*sbtree, sizeof(sb_tree), "scanbeam tree insertion", sb_tree);
+     (*sbtree)->y= y;
+     (*sbtree)->less= NULL;
+     (*sbtree)->more= NULL;
+     (*entries)++;
+   }
+   else
+   {
+     if ((*sbtree)->y > y)
+     {
+     /* Head into the 'less' sub-tree */
+       add_to_sbtree(entries, &((*sbtree)->less), y);
+     }
+     else
+     {
+       if ((*sbtree)->y < y)
+       {
+         /* Head into the 'more' sub-tree */
+         add_to_sbtree(entries, &((*sbtree)->more), y);
+       }
+     }
+   }
+ }
+ 
+ 
+ static void build_sbt(int *entries, double *sbt, sb_tree *sbtree)
+ {
+   if (sbtree->less)
+     build_sbt(entries, sbt, sbtree->less);
+   sbt[*entries]= sbtree->y;
+   (*entries)++;
+   if (sbtree->more)
+     build_sbt(entries, sbt, sbtree->more);
+ }
+ 
+ 
+ static void free_sbtree(sb_tree **sbtree)
+ {
+   if (*sbtree)
+   {
+     free_sbtree(&((*sbtree)->less));
+     free_sbtree(&((*sbtree)->more));
+     FREE(*sbtree);
+   }
+ }
+ 
+ 
+ static int count_optimal_vertices(gpc_vertex_list c)
+ {
+   int result= 0, i;
+ 
+   /* Ignore non-contributing contours */
+   if (c.num_vertices > 0)
+   {
+     for (i= 0; i < c.num_vertices; i++)
+       /* Ignore superfluous vertices embedded in horizontal edges */
+       if (OPTIMAL(c.vertex, i, c.num_vertices))
+         result++;
+   }
+   return result;
+ }
+ 
+ 
+ static edge_node *build_lmt(lmt_node **lmt, sb_tree **sbtree,
+                             int *sbt_entries, gpc_polygon *p, int type,
+                             gpc_op op)
+ {
+   int          c, i, min, max, num_edges, v, num_vertices;
+   int          total_vertices= 0, e_index=0;
+   edge_node   *e, *edge_table;
+ 
+   for (c= 0; c < p->num_contours; c++)
+     total_vertices+= count_optimal_vertices(p->contour[c]);
+ 
+   /* Create the entire input polygon edge table in one go */
+   MALLOC(edge_table, total_vertices * sizeof(edge_node),
+          "edge table creation", edge_node);
+ 
+   for (c= 0; c < p->num_contours; c++)
+   {
+     if (p->contour[c].num_vertices < 0)
+     {
+       /* Ignore the non-contributing contour and repair the vertex count */
+       p->contour[c].num_vertices= -p->contour[c].num_vertices;
+     }
+     else
+     {
+       /* Perform contour optimisation */
+       num_vertices= 0;
+       for (i= 0; i < p->contour[c].num_vertices; i++)
+         if (OPTIMAL(p->contour[c].vertex, i, p->contour[c].num_vertices))
+         {
+           edge_table[num_vertices].vertex.x= p->contour[c].vertex[i].x;
+           edge_table[num_vertices].vertex.y= p->contour[c].vertex[i].y;
+ 
+           /* Record vertex in the scanbeam table */
+           add_to_sbtree(sbt_entries, sbtree,
+                         edge_table[num_vertices].vertex.y);
+ 
+           num_vertices++;
+         }
+ 
+       /* Do the contour forward pass */
+       for (min= 0; min < num_vertices; min++)
+       {
+         /* If a forward local minimum... */
+         if (FWD_MIN(edge_table, min, num_vertices))
+         {
+           /* Search for the next local maximum... */
+           num_edges= 1;
+           max= NEXT_INDEX(min, num_vertices);
+           while (NOT_FMAX(edge_table, max, num_vertices))
+           {
+             num_edges++;
+             max= NEXT_INDEX(max, num_vertices);
+           }
+ 
+           /* Build the next edge list */
+           e= &edge_table[e_index];
+           e_index+= num_edges;
+           v= min;
+           e[0].bstate[BELOW]= UNBUNDLED;
+           e[0].bundle[BELOW][CLIP]= FALSE;
+           e[0].bundle[BELOW][SUBJ]= FALSE;
+           for (i= 0; i < num_edges; i++)
+           {
+             e[i].xb= edge_table[v].vertex.x;
+             e[i].bot.x= edge_table[v].vertex.x;
+             e[i].bot.y= edge_table[v].vertex.y;
+ 
+             v= NEXT_INDEX(v, num_vertices);
+ 
+             e[i].top.x= edge_table[v].vertex.x;
+             e[i].top.y= edge_table[v].vertex.y;
+             e[i].dx= (edge_table[v].vertex.x - e[i].bot.x) /
+                        (e[i].top.y - e[i].bot.y);
+             e[i].type= type;
+             e[i].outp[ABOVE]= NULL;
+             e[i].outp[BELOW]= NULL;
+             e[i].next= NULL;
+             e[i].prev= NULL;
+             e[i].succ= ((num_edges > 1) && (i < (num_edges - 1))) ?
+                        &(e[i + 1]) : NULL;
+             e[i].pred= ((num_edges > 1) && (i > 0)) ? &(e[i - 1]) : NULL;
+             e[i].next_bound= NULL;
+             e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;
+             e[i].bside[SUBJ]= LEFT;
+           }
+           insert_bound(bound_list(lmt, edge_table[min].vertex.y), e);
+         }
+       }
+ 
+       /* Do the contour reverse pass */
+       for (min= 0; min < num_vertices; min++)
+       {
+       /* If a reverse local minimum... */
+         if (REV_MIN(edge_table, min, num_vertices))
+         {
+           /* Search for the previous local maximum... */
+           num_edges= 1;
+           max= PREV_INDEX(min, num_vertices);
+           while (NOT_RMAX(edge_table, max, num_vertices))
+           {
+             num_edges++;
+             max= PREV_INDEX(max, num_vertices);
+           }
+ 
+           /* Build the previous edge list */
+           e= &edge_table[e_index];
+           e_index+= num_edges;
+           v= min;
+           e[0].bstate[BELOW]= UNBUNDLED;
+           e[0].bundle[BELOW][CLIP]= FALSE;
+           e[0].bundle[BELOW][SUBJ]= FALSE;
+           for (i= 0; i < num_edges; i++)
+           {
+             e[i].xb= edge_table[v].vertex.x;
+             e[i].bot.x= edge_table[v].vertex.x;
+             e[i].bot.y= edge_table[v].vertex.y;
+ 
+             v= PREV_INDEX(v, num_vertices);
+ 
+             e[i].top.x= edge_table[v].vertex.x;
+             e[i].top.y= edge_table[v].vertex.y;
+             e[i].dx= (edge_table[v].vertex.x - e[i].bot.x) /
+                        (e[i].top.y - e[i].bot.y);
+             e[i].type= type;
+             e[i].outp[ABOVE]= NULL;
+             e[i].outp[BELOW]= NULL;
+             e[i].next= NULL;
+             e[i].prev= NULL;
+             e[i].succ= ((num_edges > 1) && (i < (num_edges - 1))) ?
+                        &(e[i + 1]) : NULL;
+             e[i].pred= ((num_edges > 1) && (i > 0)) ? &(e[i - 1]) : NULL;
+             e[i].next_bound= NULL;
+             e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;
+             e[i].bside[SUBJ]= LEFT;
+           }
+           insert_bound(bound_list(lmt, edge_table[min].vertex.y), e);
+         }
+       }
+     }
+   }
+   return edge_table;
+ }
+ 
+ 
+ static void add_edge_to_aet(edge_node **aet, edge_node *edge, edge_node *prev)
+ {
+   if (!*aet)
+   {
+     /* Append edge onto the tail end of the AET */
+     *aet= edge;
+     edge->prev= prev;
+     edge->next= NULL;
+   }
+   else
+   {
+     /* Do primary sort on the xb field */
+     if (edge->xb < (*aet)->xb)
+     {
+       /* Insert edge here (before the AET edge) */
+       edge->prev= prev;
+       edge->next= *aet;
+       (*aet)->prev= edge;
+       *aet= edge;
+     }
+     else
+     {
+       if (edge->xb == (*aet)->xb)
+       {
+         /* Do secondary sort on the dx field */
+         if (edge->dx < (*aet)->dx)
+         {
+           /* Insert edge here (before the AET edge) */
+           edge->prev= prev;
+           edge->next= *aet;
+           (*aet)->prev= edge;
+           *aet= edge;
+         }
+         else
+         {
+           /* Head further into the AET */
+           add_edge_to_aet(&((*aet)->next), edge, *aet);
+         }
+       }
+       else
+       {
+         /* Head further into the AET */
+         add_edge_to_aet(&((*aet)->next), edge, *aet);
+       }
+     }
+   }
+ }
+ 
+ 
+ static void add_intersection(it_node **it, edge_node *edge0, edge_node *edge1,
+                              double x, double y)
+ {
+   it_node *existing_node;
+ 
+   if (!*it)
+   {
+     /* Append a new node to the tail of the list */
+     MALLOC(*it, sizeof(it_node), "IT insertion", it_node);
+     (*it)->ie[0]= edge0;
+     (*it)->ie[1]= edge1;
+     (*it)->point.x= x;
+     (*it)->point.y= y;
+     (*it)->next= NULL;
+   }
+   else
+   {
+     if ((*it)->point.y > y)
+     {
+       /* Insert a new node mid-list */
+       existing_node= *it;
+       MALLOC(*it, sizeof(it_node), "IT insertion", it_node);
+       (*it)->ie[0]= edge0;
+       (*it)->ie[1]= edge1;
+       (*it)->point.x= x;
+       (*it)->point.y= y;
+       (*it)->next= existing_node;
+     }
+     else
+       /* Head further down the list */
+       add_intersection(&((*it)->next), edge0, edge1, x, y);
+   }
+ }
+ 
+ 
+ static void add_st_edge(st_node **st, it_node **it, edge_node *edge,
+                         double dy)
+ {
+   st_node *existing_node;
+   double   den, r, x, y;
+ 
+   if (!*st)
+   {
+     /* Append edge onto the tail end of the ST */
+     MALLOC(*st, sizeof(st_node), "ST insertion", st_node);
+     (*st)->edge= edge;
+     (*st)->xb= edge->xb;
+     (*st)->xt= edge->xt;
+     (*st)->dx= edge->dx;
+     (*st)->prev= NULL;
+   }
+   else
+   {
+     den= ((*st)->xt - (*st)->xb) - (edge->xt - edge->xb);
+ 
+     /* If new edge and ST edge don't cross */
+     if ((edge->xt >= (*st)->xt) || (edge->dx == (*st)->dx) || 
+         (fabs(den) <= DBL_EPSILON))
+     {
+       /* No intersection - insert edge here (before the ST edge) */
+       existing_node= *st;
+       MALLOC(*st, sizeof(st_node), "ST insertion", st_node);
+       (*st)->edge= edge;
+       (*st)->xb= edge->xb;
+       (*st)->xt= edge->xt;
+       (*st)->dx= edge->dx;
+       (*st)->prev= existing_node;
+     }
+     else
+     {
+       /* Compute intersection between new edge and ST edge */
+       r= (edge->xb - (*st)->xb) / den;
+       x= (*st)->xb + r * ((*st)->xt - (*st)->xb);
+       y= r * dy;
+ 
+       /* Insert the edge pointers and the intersection point in the IT */
+       add_intersection(it, (*st)->edge, edge, x, y);
+ 
+       /* Head further into the ST */
+       add_st_edge(&((*st)->prev), it, edge, dy);
+     }
+   }
+ }
+ 
+ 
+ static void build_intersection_table(it_node **it, edge_node *aet, double dy)
+ {
+   st_node   *st, *stp;
+   edge_node *edge;
+ 
+   /* Build intersection table for the current scanbeam */
+   reset_it(it);
+   st= NULL;
+ 
+   /* Process each AET edge */
+   for (edge= aet; edge; edge= edge->next)
+   {
+     if ((edge->bstate[ABOVE] == BUNDLE_HEAD) ||
+          edge->bundle[ABOVE][CLIP] || edge->bundle[ABOVE][SUBJ])
+       add_st_edge(&st, it, edge, dy);
+   }
+ 
+   /* Free the sorted edge table */
+   while (st)
+   {
+     stp= st->prev;
+     FREE(st);
+     st= stp;
+   }
+ }
+ 
+ static int count_contours(polygon_node *polygon)
+ {
+   int          nc, nv;
+   vertex_node *v, *nextv;
+ 
+   for (nc= 0; polygon; polygon= polygon->next)
+     if (polygon->active)
+     {
+       /* Count the vertices in the current contour */
+       nv= 0;
+       for (v= polygon->proxy->v[LEFT]; v; v= v->next)
+         nv++;
+ 
+       /* Record valid vertex counts in the active field */
+       if (nv > 2)
+       {
+         polygon->active= nv;
+         nc++;
+       }
+       else
+       {
+         /* Invalid contour: just free the heap */
+         for (v= polygon->proxy->v[LEFT]; v; v= nextv)
+         {
+           nextv= v->next;
+           FREE(v);
+         }
+         polygon->active= 0;
+       }
+     }
+   return nc;
+ }
+ 
+ 
+ static void add_left(polygon_node *p, double x, double y)
+ {
+   vertex_node *nv;
+ 
+   /* Create a new vertex node and set its fields */
+   MALLOC(nv, sizeof(vertex_node), "vertex node creation", vertex_node);
+   nv->x= x;
+   nv->y= y;
+ 
+   /* Add vertex nv to the left end of the polygon's vertex list */
+   nv->next= p->proxy->v[LEFT];
+ 
+   /* Update proxy->[LEFT] to point to nv */
+   p->proxy->v[LEFT]= nv;
+ }
+ 
+ 
+ static void merge_left(polygon_node *p, polygon_node *q, polygon_node *list)
+ {
+   polygon_node *target;
+ 
+   /* Label contour as a hole */
+   q->proxy->hole= TRUE;
+ 
+   if (p->proxy != q->proxy)
+   {
+     /* Assign p's vertex list to the left end of q's list */
+     p->proxy->v[RIGHT]->next= q->proxy->v[LEFT];
+     q->proxy->v[LEFT]= p->proxy->v[LEFT];
+ 
+     /* Redirect any p->proxy references to q->proxy */
+     
+     for (target= p->proxy; list; list= list->next)
+     {
+       if (list->proxy == target)
+       {
+         list->active= FALSE;
+         list->proxy= q->proxy;
+       }
+     }
+   }
+ }
+ 
+ 
+ static void add_right(polygon_node *p, double x, double y)
+ {
+   vertex_node *nv;
+ 
+   /* Create a new vertex node and set its fields */
+   MALLOC(nv, sizeof(vertex_node), "vertex node creation", vertex_node);
+   nv->x= x;
+   nv->y= y;
+   nv->next= NULL;
+ 
+   /* Add vertex nv to the right end of the polygon's vertex list */
+   p->proxy->v[RIGHT]->next= nv;
+ 
+   /* Update proxy->v[RIGHT] to point to nv */
+   p->proxy->v[RIGHT]= nv;
+ }
+ 
+ 
+ static void merge_right(polygon_node *p, polygon_node *q, polygon_node *list)
+ {
+   polygon_node *target;
+ 
+   /* Label contour as external */
+   q->proxy->hole= FALSE;
+ 
+   if (p->proxy != q->proxy)
+   {
+     /* Assign p's vertex list to the right end of q's list */
+     q->proxy->v[RIGHT]->next= p->proxy->v[LEFT];
+     q->proxy->v[RIGHT]= p->proxy->v[RIGHT];
+ 
+     /* Redirect any p->proxy references to q->proxy */
+     for (target= p->proxy; list; list= list->next)
+     {
+       if (list->proxy == target)
+       {
+         list->active= FALSE;
+         list->proxy= q->proxy;
+       }
+     }
+   }
+ }
+ 
+ 
+ static void add_local_min(polygon_node **p, edge_node *edge,
+                           double x, double y)
+ {
+   polygon_node *existing_min;
+   vertex_node  *nv;
+ 
+   existing_min= *p;
+ 
+   MALLOC(*p, sizeof(polygon_node), "polygon node creation", polygon_node);
+ 
+   /* Create a new vertex node and set its fields */
+   MALLOC(nv, sizeof(vertex_node), "vertex node creation", vertex_node);
+   nv->x= x;
+   nv->y= y;
+   nv->next= NULL;
+ 
+   /* Initialise proxy to point to p itself */
+   (*p)->proxy= (*p);
+   (*p)->active= TRUE;
+   (*p)->next= existing_min;
+ 
+   /* Make v[LEFT] and v[RIGHT] point to new vertex nv */
+   (*p)->v[LEFT]= nv;
+   (*p)->v[RIGHT]= nv;
+ 
+   /* Assign polygon p to the edge */
+   edge->outp[ABOVE]= *p;
+ }
+ 
+ 
+ static int count_tristrips(polygon_node *tn)
+ {
+   int total;
+ 
+   for (total= 0; tn; tn= tn->next)
+     if (tn->active > 2)
+       total++;
+   return total;
+ }
+ 
+ 
+ static void add_vertex(vertex_node **t, double x, double y)
+ {
+   if (!(*t))
+   {
+     MALLOC(*t, sizeof(vertex_node), "tristrip vertex creation", vertex_node);
+     (*t)->x= x;
+     (*t)->y= y;
+     (*t)->next= NULL;
+   }
+   else
+     /* Head further down the list */
+     add_vertex(&((*t)->next), x, y);
+ }
+ 
+ 
+ static void new_tristrip(polygon_node **tn, edge_node *edge,
+                          double x, double y)
+ {
+   if (!(*tn))
+   {
+     MALLOC(*tn, sizeof(polygon_node), "tristrip node creation", polygon_node);
+     (*tn)->next= NULL;
+     (*tn)->v[LEFT]= NULL;
+     (*tn)->v[RIGHT]= NULL;
+     (*tn)->active= 1;
+     add_vertex(&((*tn)->v[LEFT]), x, y); 
+     edge->outp[ABOVE]= *tn;
+   }
+   else
+     /* Head further down the list */
+     new_tristrip(&((*tn)->next), edge, x, y);
+ }
+ 
+ 
+ static bbox *create_contour_bboxes(gpc_polygon *p)
+ {
+   bbox *box;
+   int   c, v;
+ 
+   MALLOC(box, p->num_contours * sizeof(bbox), "Bounding box creation", bbox);
+ 
+   /* Construct contour bounding boxes */
+   for (c= 0; c < p->num_contours; c++)
+   {
+     /* Initialise bounding box extent */
+     box[c].xmin= DBL_MAX;
+     box[c].ymin= DBL_MAX;
+     box[c].xmax= -DBL_MAX;
+     box[c].ymax= -DBL_MAX;
+ 
+     for (v= 0; v < p->contour[c].num_vertices; v++)
+     {
+       /* Adjust bounding box */
+       if (p->contour[c].vertex[v].x < box[c].xmin)
+         box[c].xmin= p->contour[c].vertex[v].x;
+       if (p->contour[c].vertex[v].y < box[c].ymin)
+         box[c].ymin= p->contour[c].vertex[v].y;
+       if (p->contour[c].vertex[v].x > box[c].xmax)
+         box[c].xmax= p->contour[c].vertex[v].x;
+       if (p->contour[c].vertex[v].y > box[c].ymax)
+           box[c].ymax= p->contour[c].vertex[v].y;
+     }
+   }
+   return box;  
+ }
+ 
+ 
+ static void minimax_test(gpc_polygon *subj, gpc_polygon *clip, gpc_op op)
+ {
+   bbox *s_bbox, *c_bbox;
+   int   s, c, *o_table, overlap;
+ 
+   s_bbox= create_contour_bboxes(subj);
+   c_bbox= create_contour_bboxes(clip);
+ 
+   MALLOC(o_table, subj->num_contours * clip->num_contours * sizeof(int),
+          "overlap table creation", int);
+ 
+   /* Check all subject contour bounding boxes against clip boxes */
+   for (s= 0; s < subj->num_contours; s++)
+     for (c= 0; c < clip->num_contours; c++)
+       o_table[c * subj->num_contours + s]=
+              (!((s_bbox[s].xmax < c_bbox[c].xmin) ||
+                 (s_bbox[s].xmin > c_bbox[c].xmax))) &&
+              (!((s_bbox[s].ymax < c_bbox[c].ymin) ||
+                 (s_bbox[s].ymin > c_bbox[c].ymax)));
+ 
+   /* For each clip contour, search for any subject contour overlaps */
+   for (c= 0; c < clip->num_contours; c++)
+   {
+     overlap= 0;
+     for (s= 0; (!overlap) && (s < subj->num_contours); s++)
+       overlap= o_table[c * subj->num_contours + s];
+ 
+     if (!overlap)
+       /* Flag non contributing status by negating vertex count */
+       clip->contour[c].num_vertices = -clip->contour[c].num_vertices;
+   }  
+ 
+   if (op == GPC_INT)
+   {  
+     /* For each subject contour, search for any clip contour overlaps */
+     for (s= 0; s < subj->num_contours; s++)
+     {
+       overlap= 0;
+       for (c= 0; (!overlap) && (c < clip->num_contours); c++)
+         overlap= o_table[c * subj->num_contours + s];
+ 
+       if (!overlap)
+         /* Flag non contributing status by negating vertex count */
+         subj->contour[s].num_vertices = -subj->contour[s].num_vertices;
+     }  
+   }
+ 
+   FREE(s_bbox);
+   FREE(c_bbox);
+   FREE(o_table);
+ }
+ 
+ 
+ /*
+ ===========================================================================
+                              Public Functions
+ ===========================================================================
+ */
+ 
+ void gpc_free_polygon(gpc_polygon *p)
+ {
+   int c;
+ 
+   for (c= 0; c < p->num_contours; c++)
+     FREE(p->contour[c].vertex);
+   FREE(p->hole);
+   FREE(p->contour);
+   p->num_contours= 0;
+ }
+ 
+ 
+ void gpc_read_polygon(FILE *fp, int read_hole_flags, gpc_polygon *p)
+ {
+   int c, v;
+ 
+   fscanf(fp, "%d", &(p->num_contours));
+   MALLOC(p->hole, p->num_contours * sizeof(int),
+          "hole flag array creation", int);
+   MALLOC(p->contour, p->num_contours
+          * sizeof(gpc_vertex_list), "contour creation", gpc_vertex_list);
+   for (c= 0; c < p->num_contours; c++)
+   {
+     fscanf(fp, "%d", &(p->contour[c].num_vertices));
+ 
+     if (read_hole_flags)
+       fscanf(fp, "%d", &(p->hole[c]));
+     else
+       p->hole[c]= FALSE; /* Assume all contours to be external */
+ 
+     MALLOC(p->contour[c].vertex, p->contour[c].num_vertices
+            * sizeof(gpc_vertex), "vertex creation", gpc_vertex);
+     for (v= 0; v < p->contour[c].num_vertices; v++)
+       fscanf(fp, "%lf %lf", &(p->contour[c].vertex[v].x),
+                             &(p->contour[c].vertex[v].y));
+   }
+ }
+ 
+ 
+ void gpc_write_polygon(FILE *fp, int write_hole_flags, gpc_polygon *p)
+ {
+   int c, v;
+ 
+   fprintf(fp, "%d\n", p->num_contours);
+   for (c= 0; c < p->num_contours; c++)
+   {
+     fprintf(fp, "%d\n", p->contour[c].num_vertices);
+ 
+     if (write_hole_flags)
+       fprintf(fp, "%d\n", p->hole[c]);
+     
+     for (v= 0; v < p->contour[c].num_vertices; v++)
+       fprintf(fp, "% .*lf % .*lf\n",
+               DBL_DIG, p->contour[c].vertex[v].x,
+               DBL_DIG, p->contour[c].vertex[v].y);
+   }
+ }
+ 
+ 
+ void gpc_add_contour(gpc_polygon *p, gpc_vertex_list *new_contour, int hole)
+ {
+   int             *extended_hole, c, v;
+   gpc_vertex_list *extended_contour;
+ 
+   /* Create an extended hole array */
+   MALLOC(extended_hole, (p->num_contours + 1)
+          * sizeof(int), "contour hole addition", int);
+ 
+   /* Create an extended contour array */
+   MALLOC(extended_contour, (p->num_contours + 1)
+          * sizeof(gpc_vertex_list), "contour addition", gpc_vertex_list);
+ 
+   /* Copy the old contour and hole data into the extended arrays */
+   for (c= 0; c < p->num_contours; c++)
+   {
+     extended_hole[c]= p->hole[c];
+     extended_contour[c]= p->contour[c];
+   }
+ 
+   /* Copy the new contour and hole onto the end of the extended arrays */
+   c= p->num_contours;
+   extended_hole[c]= hole;
+   extended_contour[c].num_vertices= new_contour->num_vertices;
+   MALLOC(extended_contour[c].vertex, new_contour->num_vertices
+          * sizeof(gpc_vertex), "contour addition", gpc_vertex);
+   for (v= 0; v < new_contour->num_vertices; v++)
+     extended_contour[c].vertex[v]= new_contour->vertex[v];
+ 
+   /* Dispose of the old contour */
+   FREE(p->contour);
+   FREE(p->hole);
+ 
+   /* Update the polygon information */
+   p->num_contours++;
+   p->hole= extended_hole;
+   p->contour= extended_contour;
+ }
+ 
+ 
+ void gpc_polygon_clip(gpc_op op, gpc_polygon *subj, gpc_polygon *clip,
+                       gpc_polygon *result)
+ {
+   sb_tree       *sbtree= NULL;
+   it_node       *it= NULL, *intersect;
+   edge_node     *edge, *prev_edge, *next_edge, *succ_edge, *e0, *e1;
+   edge_node     *aet= NULL, *c_heap= NULL, *s_heap= NULL;
+   lmt_node      *lmt= NULL, *local_min;
+   polygon_node  *out_poly= NULL, *p, *q, *poly, *npoly, *cf= NULL;
+   vertex_node   *vtx, *nv;
+   h_state        horiz[2];
+   int            in[2], exists[2], parity[2]= {LEFT, LEFT};
+   int            c, v, contributing, search, scanbeam= 0, sbt_entries= 0;
+   int            vclass, bl, br, tl, tr;
+   double        *sbt= NULL, xb, px, yb, yt, dy, ix, iy;
+ 
+   /* Test for trivial NULL result cases */
+   if (((subj->num_contours == 0) && (clip->num_contours == 0))
+    || ((subj->num_contours == 0) && ((op == GPC_INT) || (op == GPC_DIFF)))
+    || ((clip->num_contours == 0) &&  (op == GPC_INT)))
+   {
+     result->num_contours= 0;
+     result->hole= NULL;
+     result->contour= NULL;
+     return;
+   }
+ 
+   /* Identify potentialy contributing contours */
+   if (((op == GPC_INT) || (op == GPC_DIFF))
+    && (subj->num_contours > 0) && (clip->num_contours > 0))
+     minimax_test(subj, clip, op);
+ 
+   /* Build LMT */
+   if (subj->num_contours > 0)
+     s_heap= build_lmt(&lmt, &sbtree, &sbt_entries, subj, SUBJ, op);
+   if (clip->num_contours > 0)
+     c_heap= build_lmt(&lmt, &sbtree, &sbt_entries, clip, CLIP, op);
+ 
+   /* Return a NULL result if no contours contribute */
+   if (lmt == NULL)
+   {
+     result->num_contours= 0;
+     result->hole= NULL;
+     result->contour= NULL;
+     reset_lmt(&lmt);
+     FREE(s_heap);
+     FREE(c_heap);
+     return;
+   }
+ 
+   /* Build scanbeam table from scanbeam tree */
+   MALLOC(sbt, sbt_entries * sizeof(double), "sbt creation", double);
+   build_sbt(&scanbeam, sbt, sbtree);
+   scanbeam= 0;
+   free_sbtree(&sbtree);
+ 
+   /* Allow pointer re-use without causing memory leak */
+   if (subj == result)
+     gpc_free_polygon(subj);
+   if (clip == result)
+     gpc_free_polygon(clip);
+ 
+   /* Invert clip polygon for difference operation */
+   if (op == GPC_DIFF)
+     parity[CLIP]= RIGHT;
+ 
+   local_min= lmt;
+ 
+   /* Process each scanbeam */
+   while (scanbeam < sbt_entries)
+   {
+     /* Set yb and yt to the bottom and top of the scanbeam */
+     yb= sbt[scanbeam++];
+     if (scanbeam < sbt_entries)
+     {
+       yt= sbt[scanbeam];
+       dy= yt - yb;
+     }
+ 
+     /* === SCANBEAM BOUNDARY PROCESSING ================================ */
+ 
+     /* If LMT node corresponding to yb exists */
+     if (local_min)
+     {
+       if (local_min->y == yb)
+       {
+         /* Add edges starting at this local minimum to the AET */
+         for (edge= local_min->first_bound; edge; edge= edge->next_bound)
+           add_edge_to_aet(&aet, edge, NULL);
+ 
+         local_min= local_min->next;
+       }
+     }
+ 
+     /* Set dummy previous x value */
+     px= -DBL_MAX;
+ 
+     /* Create bundles within AET */
+     e0= aet;
+     e1= aet;
+ 
+     /* Set up bundle fields of first edge */
+     aet->bundle[ABOVE][ aet->type]= (aet->top.y != yb);
+     aet->bundle[ABOVE][!aet->type]= FALSE;
+     aet->bstate[ABOVE]= UNBUNDLED;
+ 
+     for (next_edge= aet->next; next_edge; next_edge= next_edge->next)
+     {
+       /* Set up bundle fields of next edge */
+       next_edge->bundle[ABOVE][ next_edge->type]= (next_edge->top.y != yb);
+       next_edge->bundle[ABOVE][!next_edge->type]= FALSE;
+       next_edge->bstate[ABOVE]= UNBUNDLED;
+ 
+       /* Bundle edges above the scanbeam boundary if they coincide */
+       if (next_edge->bundle[ABOVE][next_edge->type])
+       {
+         if (EQ(e0->xb, next_edge->xb) && EQ(e0->dx, next_edge->dx)
+ 	 && (e0->top.y != yb))
+         {
+           next_edge->bundle[ABOVE][ next_edge->type]^= 
+             e0->bundle[ABOVE][ next_edge->type];
+           next_edge->bundle[ABOVE][!next_edge->type]= 
+             e0->bundle[ABOVE][!next_edge->type];
+           next_edge->bstate[ABOVE]= BUNDLE_HEAD;
+           e0->bundle[ABOVE][CLIP]= FALSE;
+           e0->bundle[ABOVE][SUBJ]= FALSE;
+           e0->bstate[ABOVE]= BUNDLE_TAIL;
+         }
+         e0= next_edge;
+       }
+     }
+     
+     horiz[CLIP]= NH;
+     horiz[SUBJ]= NH;
+ 
+     /* Process each edge at this scanbeam boundary */
+     for (edge= aet; edge; edge= edge->next)
+     {
+       exists[CLIP]= edge->bundle[ABOVE][CLIP] + 
+                    (edge->bundle[BELOW][CLIP] << 1);
+       exists[SUBJ]= edge->bundle[ABOVE][SUBJ] + 
+                    (edge->bundle[BELOW][SUBJ] << 1);
+ 
+       if (exists[CLIP] || exists[SUBJ])
+       {
+         /* Set bundle side */
+         edge->bside[CLIP]= parity[CLIP];
+         edge->bside[SUBJ]= parity[SUBJ];
+ 
+         /* Determine contributing status and quadrant occupancies */
+         switch (op)
+         {
+         case GPC_DIFF:
+         case GPC_INT:
+           contributing= (exists[CLIP] && (parity[SUBJ] || horiz[SUBJ]))
+                      || (exists[SUBJ] && (parity[CLIP] || horiz[CLIP]))
+                      || (exists[CLIP] && exists[SUBJ]
+                      && (parity[CLIP] == parity[SUBJ]));
+           br= (parity[CLIP])
+            && (parity[SUBJ]);
+           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
+            && (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);
+           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+            && (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP]) 
+            && (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);
+           break;
+         case GPC_XOR:
+           contributing= exists[CLIP] || exists[SUBJ];
+           br= (parity[CLIP])
+             ^ (parity[SUBJ]);
+           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
+             ^ (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);
+           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+             ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP]) 
+             ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);
+           break;
+         case GPC_UNION:
+           contributing= (exists[CLIP] && (!parity[SUBJ] || horiz[SUBJ]))
+                      || (exists[SUBJ] && (!parity[CLIP] || horiz[CLIP]))
+                      || (exists[CLIP] && exists[SUBJ]
+                      && (parity[CLIP] == parity[SUBJ]));
+           br= (parity[CLIP])
+            || (parity[SUBJ]);
+           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
+            || (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);
+           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+            || (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP]) 
+            || (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);
+           break;
+         }
+ 
+         /* Update parity */
+         parity[CLIP]^= edge->bundle[ABOVE][CLIP];
+         parity[SUBJ]^= edge->bundle[ABOVE][SUBJ];
+ 
+         /* Update horizontal state */
+         if (exists[CLIP])         
+           horiz[CLIP]=
+             next_h_state[horiz[CLIP]]
+                         [((exists[CLIP] - 1) << 1) + parity[CLIP]];
+         if (exists[SUBJ])         
+           horiz[SUBJ]=
+             next_h_state[horiz[SUBJ]]
+                         [((exists[SUBJ] - 1) << 1) + parity[SUBJ]];
+ 
+         vclass= tr + (tl << 1) + (br << 2) + (bl << 3);
+ 
+         if (contributing)
+         {
+           xb= edge->xb;
+ 
+           switch (vclass)
+           {
+           case EMN:
+           case IMN:
+             add_local_min(&out_poly, edge, xb, yb);
+             px= xb;
+             cf= edge->outp[ABOVE];
+             break;
+           case ERI:
+             if (xb != px)
+             {
+               add_right(cf, xb, yb);
+               px= xb;
+             }
+             edge->outp[ABOVE]= cf;
+             cf= NULL;
+             break;
+           case ELI:
+             add_left(edge->outp[BELOW], xb, yb);
+             px= xb;
+             cf= edge->outp[BELOW];
+             break;
+           case EMX:
+             if (xb != px)
+             {
+               add_left(cf, xb, yb);
+               px= xb;
+             }
+             merge_right(cf, edge->outp[BELOW], out_poly);
+             cf= NULL;
+             break;
+           case ILI:
+             if (xb != px)
+             {
+               add_left(cf, xb, yb);
+               px= xb;
+             }
+             edge->outp[ABOVE]= cf;
+             cf= NULL;
+             break;
+           case IRI:
+             add_right(edge->outp[BELOW], xb, yb);
+             px= xb;
+             cf= edge->outp[BELOW];
+             edge->outp[BELOW]= NULL;
+             break;
+           case IMX:
+             if (xb != px)
+             {
+               add_right(cf, xb, yb);
+               px= xb;
+             }
+             merge_left(cf, edge->outp[BELOW], out_poly);
+             cf= NULL;
+             edge->outp[BELOW]= NULL;
+             break;
+           case IMM:
+             if (xb != px)
+ 	    {
+               add_right(cf, xb, yb);
+               px= xb;
+ 	    }
+             merge_left(cf, edge->outp[BELOW], out_poly);
+             edge->outp[BELOW]= NULL;
+             add_local_min(&out_poly, edge, xb, yb);
+             cf= edge->outp[ABOVE];
+             break;
+           case EMM:
+             if (xb != px)
+ 	    {
+               add_left(cf, xb, yb);
+               px= xb;
+ 	    }
+             merge_right(cf, edge->outp[BELOW], out_poly);
+             edge->outp[BELOW]= NULL;
+             add_local_min(&out_poly, edge, xb, yb);
+             cf= edge->outp[ABOVE];
+             break;
+           case LED:
+             if (edge->bot.y == yb)
+               add_left(edge->outp[BELOW], xb, yb);
+             edge->outp[ABOVE]= edge->outp[BELOW];
+             px= xb;
+             break;
+           case RED:
+             if (edge->bot.y == yb)
+               add_right(edge->outp[BELOW], xb, yb);
+             edge->outp[ABOVE]= edge->outp[BELOW];
+             px= xb;
+             break;
+           default:
+             break;
+           } /* End of switch */
+         } /* End of contributing conditional */
+       } /* End of edge exists conditional */
+     } /* End of AET loop */
+ 
+     /* Delete terminating edges from the AET, otherwise compute xt */
+     for (edge= aet; edge; edge= edge->next)
+     {
+       if (edge->top.y == yb)
+       {
+         prev_edge= edge->prev;
+         next_edge= edge->next;
+         if (prev_edge)
+           prev_edge->next= next_edge;
+         else
+           aet= next_edge;
+         if (next_edge)
+           next_edge->prev= prev_edge;
+ 
+         /* Copy bundle head state to the adjacent tail edge if required */
+         if ((edge->bstate[BELOW] == BUNDLE_HEAD) && prev_edge)
+ 	{
+           if (prev_edge->bstate[BELOW] == BUNDLE_TAIL)
+           {
+             prev_edge->outp[BELOW]= edge->outp[BELOW];
+             prev_edge->bstate[BELOW]= UNBUNDLED;
+             if (prev_edge->prev)
+               if (prev_edge->prev->bstate[BELOW] == BUNDLE_TAIL)
+                 prev_edge->bstate[BELOW]= BUNDLE_HEAD;
+ 	  }
+ 	}
+       }
+       else
+       {
+         if (edge->top.y == yt)
+           edge->xt= edge->top.x;
+         else
+           edge->xt= edge->bot.x + edge->dx * (yt - edge->bot.y);
+       }
+     }
+ 
+     if (scanbeam < sbt_entries)
+     {
+       /* === SCANBEAM INTERIOR PROCESSING ============================== */
+ 
+       build_intersection_table(&it, aet, dy);
+ 
+       /* Process each node in the intersection table */
+       for (intersect= it; intersect; intersect= intersect->next)
+       {
+         e0= intersect->ie[0];
+         e1= intersect->ie[1];
+ 
+         /* Only generate output for contributing intersections */
+         if ((e0->bundle[ABOVE][CLIP] || e0->bundle[ABOVE][SUBJ])
+          && (e1->bundle[ABOVE][CLIP] || e1->bundle[ABOVE][SUBJ]))
+ 	{
+           p= e0->outp[ABOVE];
+           q= e1->outp[ABOVE];
+           ix= intersect->point.x;
+           iy= intersect->point.y + yb;
+  
+           in[CLIP]= ( e0->bundle[ABOVE][CLIP] && !e0->bside[CLIP])
+                  || ( e1->bundle[ABOVE][CLIP] &&  e1->bside[CLIP])
+                  || (!e0->bundle[ABOVE][CLIP] && !e1->bundle[ABOVE][CLIP]
+                      && e0->bside[CLIP] && e1->bside[CLIP]);
+           in[SUBJ]= ( e0->bundle[ABOVE][SUBJ] && !e0->bside[SUBJ])
+                  || ( e1->bundle[ABOVE][SUBJ] &&  e1->bside[SUBJ])
+                  || (!e0->bundle[ABOVE][SUBJ] && !e1->bundle[ABOVE][SUBJ]
+                      && e0->bside[SUBJ] && e1->bside[SUBJ]);
+        
+           /* Determine quadrant occupancies */
+           switch (op)
+           {
+           case GPC_DIFF:
+           case GPC_INT:
+             tr= (in[CLIP])
+              && (in[SUBJ]);
+             tl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP])
+              && (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ]);
+             br= (in[CLIP] ^ e0->bundle[ABOVE][CLIP])
+              && (in[SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
+              && (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             break;
+           case GPC_XOR:
+             tr= (in[CLIP])
+               ^ (in[SUBJ]);
+             tl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP])
+               ^ (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ]);
+             br= (in[CLIP] ^ e0->bundle[ABOVE][CLIP])
+               ^ (in[SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
+               ^ (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             break;
+           case GPC_UNION:
+             tr= (in[CLIP])
+              || (in[SUBJ]);
+             tl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP])
+              || (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ]);
+             br= (in[CLIP] ^ e0->bundle[ABOVE][CLIP])
+              || (in[SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
+              || (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             break;
+           }
+ 	  
+           vclass= tr + (tl << 1) + (br << 2) + (bl << 3);
+ 
+           switch (vclass)
+           {
+           case EMN:
+             add_local_min(&out_poly, e0, ix, iy);
+             e1->outp[ABOVE]= e0->outp[ABOVE];
+             break;
+           case ERI:
+             if (p)
+             {
+               add_right(p, ix, iy);
+               e1->outp[ABOVE]= p;
+               e0->outp[ABOVE]= NULL;
+             }
+             break;
+           case ELI:
+             if (q)
+             {
+               add_left(q, ix, iy);
+               e0->outp[ABOVE]= q;
+               e1->outp[ABOVE]= NULL;
+             }
+             break;
+           case EMX:
+             if (p && q)
+             {
+               add_left(p, ix, iy);
+               merge_right(p, q, out_poly);
+               e0->outp[ABOVE]= NULL;
+               e1->outp[ABOVE]= NULL;
+             }
+             break;
+           case IMN:
+             add_local_min(&out_poly, e0, ix, iy);
+             e1->outp[ABOVE]= e0->outp[ABOVE];
+             break;
+           case ILI:
+             if (p)
+             {
+               add_left(p, ix, iy);
+               e1->outp[ABOVE]= p;
+               e0->outp[ABOVE]= NULL;
+             }
+             break;
+           case IRI:
+             if (q)
+             {
+               add_right(q, ix, iy);
+               e0->outp[ABOVE]= q;
+               e1->outp[ABOVE]= NULL;
+             }
+             break;
+           case IMX:
+             if (p && q)
+             {
+               add_right(p, ix, iy);
+               merge_left(p, q, out_poly);
+               e0->outp[ABOVE]= NULL;
+               e1->outp[ABOVE]= NULL;
+             }
+             break;
+           case IMM:
+             if (p && q)
+             {
+               add_right(p, ix, iy);
+               merge_left(p, q, out_poly);
+               add_local_min(&out_poly, e0, ix, iy);
+               e1->outp[ABOVE]= e0->outp[ABOVE];
+             }
+             break;
+           case EMM:
+             if (p && q)
+             {
+               add_left(p, ix, iy);
+               merge_right(p, q, out_poly);
+               add_local_min(&out_poly, e0, ix, iy);
+               e1->outp[ABOVE]= e0->outp[ABOVE];
+             }
+             break;
+           default:
+             break;
+           } /* End of switch */
+ 	} /* End of contributing intersection conditional */
+ 
+         /* Swap bundle sides in response to edge crossing */
+         if (e0->bundle[ABOVE][CLIP])
+ 	  e1->bside[CLIP]= !e1->bside[CLIP];
+         if (e1->bundle[ABOVE][CLIP])
+ 	  e0->bside[CLIP]= !e0->bside[CLIP];
+         if (e0->bundle[ABOVE][SUBJ])
+ 	  e1->bside[SUBJ]= !e1->bside[SUBJ];
+         if (e1->bundle[ABOVE][SUBJ])
+ 	  e0->bside[SUBJ]= !e0->bside[SUBJ];
+ 
+         /* Swap e0 and e1 bundles in the AET */
+         prev_edge= e0->prev;
+         next_edge= e1->next;
+         if (next_edge)
+           next_edge->prev= e0;
+ 
+         if (e0->bstate[ABOVE] == BUNDLE_HEAD)
+         {
+           search= TRUE;
+           while (search)
+           {
+             prev_edge= prev_edge->prev;
+             if (prev_edge)
+             {
+               if (prev_edge->bstate[ABOVE] != BUNDLE_TAIL)
+                 search= FALSE;
+             }
+             else
+               search= FALSE;
+           }
+         }
+         if (!prev_edge)
+         {
+           aet->prev= e1;
+           e1->next= aet;
+           aet= e0->next;
+         }
+         else
+         {
+           prev_edge->next->prev= e1;
+           e1->next= prev_edge->next;
+           prev_edge->next= e0->next;
+         }
+         e0->next->prev= prev_edge;
+         e1->next->prev= e1;
+         e0->next= next_edge;
+       } /* End of IT loop*/
+ 
+       /* Prepare for next scanbeam */
+       for (edge= aet; edge; edge= next_edge)
+       {
+         next_edge= edge->next;
+         succ_edge= edge->succ;
+ 
+         if ((edge->top.y == yt) && succ_edge)
+         {
+           /* Replace AET edge by its successor */
+           succ_edge->outp[BELOW]= edge->outp[ABOVE];
+           succ_edge->bstate[BELOW]= edge->bstate[ABOVE];
+           succ_edge->bundle[BELOW][CLIP]= edge->bundle[ABOVE][CLIP];
+           succ_edge->bundle[BELOW][SUBJ]= edge->bundle[ABOVE][SUBJ];
+           prev_edge= edge->prev;
+           if (prev_edge)
+             prev_edge->next= succ_edge;
+           else
+             aet= succ_edge;
+           if (next_edge)
+             next_edge->prev= succ_edge;
+           succ_edge->prev= prev_edge;
+           succ_edge->next= next_edge;
+         }
+         else
+         {
+           /* Update this edge */
+           edge->outp[BELOW]= edge->outp[ABOVE];
+           edge->bstate[BELOW]= edge->bstate[ABOVE];
+           edge->bundle[BELOW][CLIP]= edge->bundle[ABOVE][CLIP];
+           edge->bundle[BELOW][SUBJ]= edge->bundle[ABOVE][SUBJ];
+           edge->xb= edge->xt;
+ 	      }
+         edge->outp[ABOVE]= NULL;
+       }
+     }
+   } /* === END OF SCANBEAM PROCESSING ================================== */
+ 
+   /* Generate result polygon from out_poly */
+   result->contour= NULL;
+   result->hole= NULL;
+   result->num_contours= count_contours(out_poly);
+   if (result->num_contours > 0)
+   {
+     MALLOC(result->hole, result->num_contours
+            * sizeof(int), "hole flag table creation", int);
+     MALLOC(result->contour, result->num_contours
+            * sizeof(gpc_vertex_list), "contour creation", gpc_vertex_list);
+ 
+     c= 0;
+     for (poly= out_poly; poly; poly= npoly)
+     {
+       npoly= poly->next;
+       if (poly->active)
+       {
+         result->hole[c]= poly->proxy->hole;
+         result->contour[c].num_vertices= poly->active;
+         MALLOC(result->contour[c].vertex,
+           result->contour[c].num_vertices * sizeof(gpc_vertex),
+           "vertex creation", gpc_vertex);
+       
+         v= result->contour[c].num_vertices - 1;
+         for (vtx= poly->proxy->v[LEFT]; vtx; vtx= nv)
+         {
+           nv= vtx->next;
+           result->contour[c].vertex[v].x= vtx->x;
+           result->contour[c].vertex[v].y= vtx->y;
+           FREE(vtx);
+           v--;
+         }
+         c++;
+       }
+       FREE(poly);
+     }
+   }
+   else
+   {
+     for (poly= out_poly; poly; poly= npoly)
+     {
+       npoly= poly->next;
+       FREE(poly);
+     }
+   }
+ 
+   /* Tidy up */
+   reset_it(&it);
+   reset_lmt(&lmt);
+   FREE(c_heap);
+   FREE(s_heap);
+   FREE(sbt);
+ }
+ 
+ 
+ void gpc_free_tristrip(gpc_tristrip *t)
+ {
+   int s;
+ 
+   for (s= 0; s < t->num_strips; s++)
+     FREE(t->strip[s].vertex);
+   FREE(t->strip);
+   t->num_strips= 0;
+ }
+ 
+ 
+ void gpc_polygon_to_tristrip(gpc_polygon *s, gpc_tristrip *t)
+ {
+   gpc_polygon c;
+ 
+   c.num_contours= 0;
+   c.hole= NULL;
+   c.contour= NULL;
+   gpc_tristrip_clip(GPC_DIFF, s, &c, t);
+ }
+ 
+ 
+ void gpc_tristrip_clip(gpc_op op, gpc_polygon *subj, gpc_polygon *clip,
+                        gpc_tristrip *result)
+ {
+   sb_tree       *sbtree= NULL;
+   it_node       *it= NULL, *intersect;
+   edge_node     *edge, *prev_edge, *next_edge, *succ_edge, *e0, *e1;
+   edge_node     *aet= NULL, *c_heap= NULL, *s_heap= NULL, *cf;
+   lmt_node      *lmt= NULL, *local_min;
+   polygon_node  *tlist= NULL, *tn, *tnn, *p, *q;
+   vertex_node   *lt, *ltn, *rt, *rtn;
+   h_state        horiz[2];
+   vertex_type    cft;
+   int            in[2], exists[2], parity[2]= {LEFT, LEFT};
+   int            s, v, contributing, search, scanbeam= 0, sbt_entries= 0;
+   int            vclass, bl, br, tl, tr;
+   double        *sbt= NULL, xb, px, nx, yb, yt, dy, ix, iy;
+ 
+   /* Test for trivial NULL result cases */
+   if (((subj->num_contours == 0) && (clip->num_contours == 0))
+    || ((subj->num_contours == 0) && ((op == GPC_INT) || (op == GPC_DIFF)))
+    || ((clip->num_contours == 0) &&  (op == GPC_INT)))
+   {
+     result->num_strips= 0;
+     result->strip= NULL;
+     return;
+   }
+ 
+   /* Identify potentialy contributing contours */
+   if (((op == GPC_INT) || (op == GPC_DIFF))
+    && (subj->num_contours > 0) && (clip->num_contours > 0))
+     minimax_test(subj, clip, op);
+ 
+   /* Build LMT */
+   if (subj->num_contours > 0)
+     s_heap= build_lmt(&lmt, &sbtree, &sbt_entries, subj, SUBJ, op);
+   if (clip->num_contours > 0)
+     c_heap= build_lmt(&lmt, &sbtree, &sbt_entries, clip, CLIP, op);
+ 
+   /* Return a NULL result if no contours contribute */
+   if (lmt == NULL)
+   {
+     result->num_strips= 0;
+     result->strip= NULL;
+     reset_lmt(&lmt);
+     FREE(s_heap);
+     FREE(c_heap);
+     return;
+   }
+ 
+   /* Build scanbeam table from scanbeam tree */
+   MALLOC(sbt, sbt_entries * sizeof(double), "sbt creation", double);
+   build_sbt(&scanbeam, sbt, sbtree);
+   scanbeam= 0;
+   free_sbtree(&sbtree);
+ 
+   /* Invert clip polygon for difference operation */
+   if (op == GPC_DIFF)
+     parity[CLIP]= RIGHT;
+ 
+   local_min= lmt;
+ 
+   /* Process each scanbeam */
+   while (scanbeam < sbt_entries)
+   {
+     /* Set yb and yt to the bottom and top of the scanbeam */
+     yb= sbt[scanbeam++];
+     if (scanbeam < sbt_entries)
+     {
+       yt= sbt[scanbeam];
+       dy= yt - yb;
+     }
+ 
+     /* === SCANBEAM BOUNDARY PROCESSING ================================ */
+ 
+     /* If LMT node corresponding to yb exists */
+     if (local_min)
+     {
+       if (local_min->y == yb)
+       {
+         /* Add edges starting at this local minimum to the AET */
+         for (edge= local_min->first_bound; edge; edge= edge->next_bound)
+           add_edge_to_aet(&aet, edge, NULL);
+ 
+         local_min= local_min->next;
+       }
+     }
+ 
+     /* Set dummy previous x value */
+     px= -DBL_MAX;
+ 
+     /* Create bundles within AET */
+     e0= aet;
+     e1= aet;
+ 
+     /* Set up bundle fields of first edge */
+     aet->bundle[ABOVE][ aet->type]= (aet->top.y != yb);
+     aet->bundle[ABOVE][!aet->type]= FALSE;
+     aet->bstate[ABOVE]= UNBUNDLED;
+ 
+     for (next_edge= aet->next; next_edge; next_edge= next_edge->next)
+     {
+       /* Set up bundle fields of next edge */
+       next_edge->bundle[ABOVE][ next_edge->type]= (next_edge->top.y != yb);
+       next_edge->bundle[ABOVE][!next_edge->type]= FALSE;
+       next_edge->bstate[ABOVE]= UNBUNDLED;
+ 
+       /* Bundle edges above the scanbeam boundary if they coincide */
+       if (next_edge->bundle[ABOVE][next_edge->type])
+       {
+         if (EQ(e0->xb, next_edge->xb) && EQ(e0->dx, next_edge->dx)
+ 	 && (e0->top.y != yb))
+         {
+           next_edge->bundle[ABOVE][ next_edge->type]^= 
+             e0->bundle[ABOVE][ next_edge->type];
+           next_edge->bundle[ABOVE][!next_edge->type]= 
+             e0->bundle[ABOVE][!next_edge->type]; 
+           next_edge->bstate[ABOVE]= BUNDLE_HEAD;
+           e0->bundle[ABOVE][CLIP]= FALSE;
+           e0->bundle[ABOVE][SUBJ]= FALSE;
+           e0->bstate[ABOVE]= BUNDLE_TAIL;
+         }
+         e0= next_edge;
+       }
+     }
+ 
+     horiz[CLIP]= NH;
+     horiz[SUBJ]= NH;
+ 
+     /* Process each edge at this scanbeam boundary */
+     for (edge= aet; edge; edge= edge->next)
+     {
+       exists[CLIP]= edge->bundle[ABOVE][CLIP] + 
+                    (edge->bundle[BELOW][CLIP] << 1);
+       exists[SUBJ]= edge->bundle[ABOVE][SUBJ] + 
+                    (edge->bundle[BELOW][SUBJ] << 1);
+ 
+       if (exists[CLIP] || exists[SUBJ])
+       {
+         /* Set bundle side */
+         edge->bside[CLIP]= parity[CLIP];
+         edge->bside[SUBJ]= parity[SUBJ];
+ 
+         /* Determine contributing status and quadrant occupancies */
+         switch (op)
+         {
+         case GPC_DIFF:
+         case GPC_INT:
+           contributing= (exists[CLIP] && (parity[SUBJ] || horiz[SUBJ]))
+                      || (exists[SUBJ] && (parity[CLIP] || horiz[CLIP]))
+                      || (exists[CLIP] && exists[SUBJ]
+                      && (parity[CLIP] == parity[SUBJ]));
+           br= (parity[CLIP])
+            && (parity[SUBJ]);
+           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
+            && (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);
+           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+            && (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP]) 
+            && (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);
+           break;
+         case GPC_XOR:
+           contributing= exists[CLIP] || exists[SUBJ];
+           br= (parity[CLIP])
+             ^ (parity[SUBJ]);
+           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
+             ^ (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);
+           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+             ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP])
+             ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);
+           break;
+         case GPC_UNION:
+           contributing= (exists[CLIP] && (!parity[SUBJ] || horiz[SUBJ]))
+                      || (exists[SUBJ] && (!parity[CLIP] || horiz[CLIP]))
+                      || (exists[CLIP] && exists[SUBJ]
+                      && (parity[CLIP] == parity[SUBJ]));
+           br= (parity[CLIP])
+            || (parity[SUBJ]);
+           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
+            || (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);
+           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+            || (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP])
+            || (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);
+           break;
+         }
+ 
+         /* Update parity */
+         parity[CLIP]^= edge->bundle[ABOVE][CLIP];
+         parity[SUBJ]^= edge->bundle[ABOVE][SUBJ];
+ 
+         /* Update horizontal state */
+         if (exists[CLIP])         
+           horiz[CLIP]=
+             next_h_state[horiz[CLIP]]
+                         [((exists[CLIP] - 1) << 1) + parity[CLIP]];
+         if (exists[SUBJ])         
+           horiz[SUBJ]=
+             next_h_state[horiz[SUBJ]]
+                         [((exists[SUBJ] - 1) << 1) + parity[SUBJ]];
+         
+         vclass= tr + (tl << 1) + (br << 2) + (bl << 3);
+ 
+         if (contributing)
+         {
+           xb= edge->xb;
+ 
+           switch (vclass)
+           {
+           case EMN:
+             new_tristrip(&tlist, edge, xb, yb);
+             cf= edge;
+             break;
+           case ERI:
+             edge->outp[ABOVE]= cf->outp[ABOVE];
+             if (xb != cf->xb)
+               VERTEX(edge, ABOVE, RIGHT, xb, yb);
+             cf= NULL;
+             break;
+           case ELI:
+             VERTEX(edge, BELOW, LEFT, xb, yb);
+             edge->outp[ABOVE]= NULL;
+             cf= edge;
+             break;
+           case EMX:
+             if (xb != cf->xb)
+               VERTEX(edge, BELOW, RIGHT, xb, yb);
+             edge->outp[ABOVE]= NULL;
+             cf= NULL;
+             break;
+           case IMN:
+             if (cft == LED)
+ 	    {
+               if (cf->bot.y != yb)
+                 VERTEX(cf, BELOW, LEFT, cf->xb, yb);
+               new_tristrip(&tlist, cf, cf->xb, yb);
+ 	    }
+             edge->outp[ABOVE]= cf->outp[ABOVE];
+             VERTEX(edge, ABOVE, RIGHT, xb, yb);
+             break;
+           case ILI:
+             new_tristrip(&tlist, edge, xb, yb);
+             cf= edge;
+             cft= ILI;
+             break;
+           case IRI:
+             if (cft == LED)
+ 	    {
+               if (cf->bot.y != yb)
+                 VERTEX(cf, BELOW, LEFT, cf->xb, yb);
+               new_tristrip(&tlist, cf, cf->xb, yb);
+ 	    }
+             VERTEX(edge, BELOW, RIGHT, xb, yb);
+             edge->outp[ABOVE]= NULL;
+             break;
+           case IMX:
+             VERTEX(edge, BELOW, LEFT, xb, yb);
+             edge->outp[ABOVE]= NULL;
+             cft= IMX;
+             break;
+ 	  case IMM:
+             VERTEX(edge, BELOW, LEFT, xb, yb);
+             edge->outp[ABOVE]= cf->outp[ABOVE];
+             if (xb != cf->xb)
+               VERTEX(cf, ABOVE, RIGHT, xb, yb);
+             cf= edge;
+             break;
+           case EMM:
+             VERTEX(edge, BELOW, RIGHT, xb, yb);
+             edge->outp[ABOVE]= NULL;
+             new_tristrip(&tlist, edge, xb, yb);
+             cf= edge;
+             break;
+           case LED:
+             if (edge->bot.y == yb)
+               VERTEX(edge, BELOW, LEFT, xb, yb);
+             edge->outp[ABOVE]= edge->outp[BELOW];
+             cf= edge;
+             cft= LED;
+             break;
+           case RED:
+             edge->outp[ABOVE]= cf->outp[ABOVE];
+             if (cft == LED)
+ 	    {
+               if (cf->bot.y == yb)
+ 	      {
+                 VERTEX(edge, BELOW, RIGHT, xb, yb);
+ 	      }
+               else
+ 	      {
+                 if (edge->bot.y == yb)
+ 		{
+                   VERTEX(cf, BELOW, LEFT, cf->xb, yb);
+                   VERTEX(edge, BELOW, RIGHT, xb, yb);
+ 		}
+ 	      }
+ 	    }
+             else
+ 	    {
+               VERTEX(edge, BELOW, RIGHT, xb, yb);
+               VERTEX(edge, ABOVE, RIGHT, xb, yb);
+ 	    }
+             cf= NULL;
+             break;
+           default:
+             break;
+           } /* End of switch */
+         } /* End of contributing conditional */
+       } /* End of edge exists conditional */
+     } /* End of AET loop */
+ 
+     /* Delete terminating edges from the AET, otherwise compute xt */
+     for (edge= aet; edge; edge= edge->next)
+     {
+       if (edge->top.y == yb)
+       {
+         prev_edge= edge->prev;
+         next_edge= edge->next;
+         if (prev_edge)
+           prev_edge->next= next_edge;
+         else
+           aet= next_edge;
+         if (next_edge)
+           next_edge->prev= prev_edge;
+ 
+         /* Copy bundle head state to the adjacent tail edge if required */
+         if ((edge->bstate[BELOW] == BUNDLE_HEAD) && prev_edge)
+ 	{
+           if (prev_edge->bstate[BELOW] == BUNDLE_TAIL)
+           {
+             prev_edge->outp[BELOW]= edge->outp[BELOW];
+             prev_edge->bstate[BELOW]= UNBUNDLED;
+             if (prev_edge->prev)
+               if (prev_edge->prev->bstate[BELOW] == BUNDLE_TAIL)
+                 prev_edge->bstate[BELOW]= BUNDLE_HEAD;
+ 	  }
+ 	}
+       }
+       else
+       {
+         if (edge->top.y == yt)
+           edge->xt= edge->top.x;
+         else
+           edge->xt= edge->bot.x + edge->dx * (yt - edge->bot.y);
+       }
+     }
+ 
+     if (scanbeam < sbt_entries)
+     {
+       /* === SCANBEAM INTERIOR PROCESSING ============================== */
+   
+       build_intersection_table(&it, aet, dy);
+ 
+       /* Process each node in the intersection table */
+       for (intersect= it; intersect; intersect= intersect->next)
+       {
+         e0= intersect->ie[0];
+         e1= intersect->ie[1];
+ 
+         /* Only generate output for contributing intersections */
+         if ((e0->bundle[ABOVE][CLIP] || e0->bundle[ABOVE][SUBJ])
+          && (e1->bundle[ABOVE][CLIP] || e1->bundle[ABOVE][SUBJ]))
+ 	{
+           p= e0->outp[ABOVE];
+           q= e1->outp[ABOVE];
+           ix= intersect->point.x;
+           iy= intersect->point.y + yb;
+ 
+           in[CLIP]= ( e0->bundle[ABOVE][CLIP] && !e0->bside[CLIP])
+                  || ( e1->bundle[ABOVE][CLIP] &&  e1->bside[CLIP])
+                  || (!e0->bundle[ABOVE][CLIP] && !e1->bundle[ABOVE][CLIP]
+                      && e0->bside[CLIP] && e1->bside[CLIP]);
+           in[SUBJ]= ( e0->bundle[ABOVE][SUBJ] && !e0->bside[SUBJ])
+                  || ( e1->bundle[ABOVE][SUBJ] &&  e1->bside[SUBJ])
+                  || (!e0->bundle[ABOVE][SUBJ] && !e1->bundle[ABOVE][SUBJ]
+                      && e0->bside[SUBJ] && e1->bside[SUBJ]);
+ 
+           /* Determine quadrant occupancies */
+           switch (op)
+           {
+           case GPC_DIFF:
+           case GPC_INT:
+             tr= (in[CLIP])
+              && (in[SUBJ]);
+             tl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP])
+              && (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ]);
+             br= (in[CLIP] ^ e0->bundle[ABOVE][CLIP])
+              && (in[SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
+              && (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             break;
+           case GPC_XOR:
+             tr= (in[CLIP])
+               ^ (in[SUBJ]);
+             tl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP])
+               ^ (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ]);
+             br= (in[CLIP] ^ e0->bundle[ABOVE][CLIP])
+               ^ (in[SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
+               ^ (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             break;
+           case GPC_UNION:
+             tr= (in[CLIP])
+              || (in[SUBJ]);
+             tl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP])
+              || (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ]);
+             br= (in[CLIP] ^ e0->bundle[ABOVE][CLIP])
+              || (in[SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
+              || (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);
+             break;
+           }
+ 
+           vclass= tr + (tl << 1) + (br << 2) + (bl << 3);
+ 
+           switch (vclass)
+           {
+           case EMN:
+             new_tristrip(&tlist, e1, ix, iy);
+             e0->outp[ABOVE]= e1->outp[ABOVE];
+             break;
+           case ERI:
+             if (p)
+             {
+               P_EDGE(prev_edge, e0, ABOVE, px, iy);
+               VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+               VERTEX(e0, ABOVE, RIGHT, ix, iy);
+               e1->outp[ABOVE]= e0->outp[ABOVE];
+               e0->outp[ABOVE]= NULL;
+             }
+             break;
+           case ELI:
+             if (q)
+             {
+               N_EDGE(next_edge, e1, ABOVE, nx, iy);
+               VERTEX(e1, ABOVE, LEFT, ix, iy);
+               VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+               e0->outp[ABOVE]= e1->outp[ABOVE];
+               e1->outp[ABOVE]= NULL;
+             }
+             break;
+           case EMX:
+             if (p && q)
+             {
+               VERTEX(e0, ABOVE, LEFT, ix, iy);
+               e0->outp[ABOVE]= NULL;
+               e1->outp[ABOVE]= NULL;
+             }
+             break;
+           case IMN:
+             P_EDGE(prev_edge, e0, ABOVE, px, iy);
+             VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+             N_EDGE(next_edge, e1, ABOVE, nx, iy);
+             VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+             new_tristrip(&tlist, prev_edge, px, iy); 
+             e1->outp[ABOVE]= prev_edge->outp[ABOVE];
+             VERTEX(e1, ABOVE, RIGHT, ix, iy);
+             new_tristrip(&tlist, e0, ix, iy);
+             next_edge->outp[ABOVE]= e0->outp[ABOVE];
+             VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+             break;
+           case ILI:
+             if (p)
+             {
+               VERTEX(e0, ABOVE, LEFT, ix, iy);
+               N_EDGE(next_edge, e1, ABOVE, nx, iy);
+               VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+               e1->outp[ABOVE]= e0->outp[ABOVE];
+               e0->outp[ABOVE]= NULL;
+             }
+             break;
+           case IRI:
+             if (q)
+             {
+               VERTEX(e1, ABOVE, RIGHT, ix, iy);
+               P_EDGE(prev_edge, e0, ABOVE, px, iy);
+               VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+               e0->outp[ABOVE]= e1->outp[ABOVE];
+               e1->outp[ABOVE]= NULL;
+             }
+             break;
+           case IMX:
+             if (p && q)
+             {
+               VERTEX(e0, ABOVE, RIGHT, ix, iy);
+               VERTEX(e1, ABOVE, LEFT, ix, iy);
+               e0->outp[ABOVE]= NULL;
+               e1->outp[ABOVE]= NULL;
+               P_EDGE(prev_edge, e0, ABOVE, px, iy);
+               VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+               new_tristrip(&tlist, prev_edge, px, iy);
+               N_EDGE(next_edge, e1, ABOVE, nx, iy);
+               VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+               next_edge->outp[ABOVE]= prev_edge->outp[ABOVE];
+               VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+             }
+             break;
+           case IMM:
+             if (p && q)
+             {
+               VERTEX(e0, ABOVE, RIGHT, ix, iy);
+               VERTEX(e1, ABOVE, LEFT, ix, iy);
+               P_EDGE(prev_edge, e0, ABOVE, px, iy);
+               VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+               new_tristrip(&tlist, prev_edge, px, iy);
+               N_EDGE(next_edge, e1, ABOVE, nx, iy);
+               VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+               e1->outp[ABOVE]= prev_edge->outp[ABOVE];
+               VERTEX(e1, ABOVE, RIGHT, ix, iy);
+               new_tristrip(&tlist, e0, ix, iy);
+               next_edge->outp[ABOVE]= e0->outp[ABOVE];
+               VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+             }
+             break;
+           case EMM:
+             if (p && q)
+             {
+               VERTEX(e0, ABOVE, LEFT, ix, iy);
+               new_tristrip(&tlist, e1, ix, iy);
+               e0->outp[ABOVE]= e1->outp[ABOVE];
+             }
+             break;
+           default:
+             break;
+           } /* End of switch */
+ 	} /* End of contributing intersection conditional */
+ 
+         /* Swap bundle sides in response to edge crossing */
+         if (e0->bundle[ABOVE][CLIP])
+ 	  e1->bside[CLIP]= !e1->bside[CLIP];
+         if (e1->bundle[ABOVE][CLIP])
+ 	  e0->bside[CLIP]= !e0->bside[CLIP];
+         if (e0->bundle[ABOVE][SUBJ])
+ 	  e1->bside[SUBJ]= !e1->bside[SUBJ];
+         if (e1->bundle[ABOVE][SUBJ])
+ 	  e0->bside[SUBJ]= !e0->bside[SUBJ];
+ 
+         /* Swap e0 and e1 bundles in the AET */
+         prev_edge= e0->prev;
+         next_edge= e1->next;
+         if (e1->next)
+           e1->next->prev= e0;
+ 
+         if (e0->bstate[ABOVE] == BUNDLE_HEAD)
+         {
+           search= TRUE;
+           while (search)
+           {
+             prev_edge= prev_edge->prev;
+             if (prev_edge)
+             {
+               if (prev_edge->bundle[ABOVE][CLIP]
+                || prev_edge->bundle[ABOVE][SUBJ]
+                || (prev_edge->bstate[ABOVE] == BUNDLE_HEAD))
+                 search= FALSE;
+             }
+             else
+               search= FALSE;
+           }
+         }
+         if (!prev_edge)
+         {
+            e1->next= aet;
+            aet= e0->next;
+         }
+         else
+         {
+           e1->next= prev_edge->next;
+           prev_edge->next= e0->next;
+         }
+         e0->next->prev= prev_edge;
+         e1->next->prev= e1;
+         e0->next= next_edge;
+       } /* End of IT loop*/
+ 
+       /* Prepare for next scanbeam */
+       for (edge= aet; edge; edge= next_edge)
+       {
+         next_edge= edge->next;
+         succ_edge= edge->succ;
+ 
+         if ((edge->top.y == yt) && succ_edge)
+         {
+           /* Replace AET edge by its successor */
+           succ_edge->outp[BELOW]= edge->outp[ABOVE];
+           succ_edge->bstate[BELOW]= edge->bstate[ABOVE];
+           succ_edge->bundle[BELOW][CLIP]= edge->bundle[ABOVE][CLIP];
+           succ_edge->bundle[BELOW][SUBJ]= edge->bundle[ABOVE][SUBJ];
+           prev_edge= edge->prev;
+           if (prev_edge)
+             prev_edge->next= succ_edge;
+           else
+             aet= succ_edge;
+           if (next_edge)
+             next_edge->prev= succ_edge;
+           succ_edge->prev= prev_edge;
+           succ_edge->next= next_edge;
+         }
+         else
+         {
+           /* Update this edge */
+           edge->outp[BELOW]= edge->outp[ABOVE];
+           edge->bstate[BELOW]= edge->bstate[ABOVE];
+           edge->bundle[BELOW][CLIP]= edge->bundle[ABOVE][CLIP];
+           edge->bundle[BELOW][SUBJ]= edge->bundle[ABOVE][SUBJ];
+           edge->xb= edge->xt;
+         }
+         edge->outp[ABOVE]= NULL;
+       }
+     }
+   } /* === END OF SCANBEAM PROCESSING ================================== */
+ 
+   /* Generate result tristrip from tlist */
+   result->strip= NULL;
+   result->num_strips= count_tristrips(tlist);
+   if (result->num_strips > 0)
+   {
+     MALLOC(result->strip, result->num_strips * sizeof(gpc_vertex_list),
+            "tristrip list creation", gpc_vertex_list);
+ 
+     s= 0;
+     for (tn= tlist; tn; tn= tnn)
+     {
+       tnn= tn->next;
+ 
+       if (tn->active > 2)
+       {
+         /* Valid tristrip: copy the vertices and free the heap */
+         result->strip[s].num_vertices= tn->active;
+         MALLOC(result->strip[s].vertex, tn->active * sizeof(gpc_vertex),
+                "tristrip creation", gpc_vertex);
+         v= 0;
+         if (INVERT_TRISTRIPS)
+         {
+           lt= tn->v[RIGHT];
+           rt= tn->v[LEFT];
+         }
+         else
+         {
+           lt= tn->v[LEFT];
+           rt= tn->v[RIGHT];
+         }
+         while (lt || rt)
+         {
+           if (lt)
+           {
+             ltn= lt->next;
+             result->strip[s].vertex[v].x= lt->x;
+             result->strip[s].vertex[v].y= lt->y;
+             v++;
+             FREE(lt);
+             lt= ltn;
+           }
+           if (rt)
+           {
+             rtn= rt->next;
+             result->strip[s].vertex[v].x= rt->x;
+             result->strip[s].vertex[v].y= rt->y;
+             v++;
+             FREE(rt);
+             rt= rtn;
+           }
+         }
+         s++;
+       }
+       else
+       {
+         /* Invalid tristrip: just free the heap */
+         for (lt= tn->v[LEFT]; lt; lt= ltn)
+         {
+           ltn= lt->next;
+           FREE(lt);
+         }
+         for (rt= tn->v[RIGHT]; rt; rt=rtn)
+         {
+           rtn= rt->next;
+           FREE(rt);
+         }
+       }
+       FREE(tn);
+     }
+   }
+ 
+   /* Tidy up */
+   reset_it(&it);
+   reset_lmt(&lmt);
+   FREE(c_heap);
+   FREE(s_heap);
+   FREE(sbt);
+ }
+ 
+ /*
+ ===========================================================================
+                            End of file: gpc.c
+ ===========================================================================
+ */
*** ./external/gpc/gpc.h.osr6	Wed Oct 26 20:22:51 2005
--- ./external/gpc/gpc.h	Wed Oct 26 20:22:51 2005
***************
*** 0 ****
--- 1,133 ----
+ /*
+ ===========================================================================
+ 
+ Project:   Generic Polygon Clipper
+ 
+            A new algorithm for calculating the difference, intersection,
+            exclusive-or or union of arbitrary polygon sets.
+ 
+ File:      gpc.h
+ Author:    Alan Murta (email: gpc@cs.man.ac.uk)
+ Version:   2.32
+ Date:      17th December 2004
+ 
+ Copyright: (C) 1997-2004, Advanced Interfaces Group,
+            University of Manchester.
+ 
+            This software is free for non-commercial use. It may be copied,
+            modified, and redistributed provided that this copyright notice
+            is preserved on all copies. The intellectual property rights of
+            the algorithms used reside with the University of Manchester
+            Advanced Interfaces Group.
+ 
+            You may not use this software, in whole or in part, in support
+            of any commercial product without the express consent of the
+            author.
+ 
+            There is no warranty or other guarantee of fitness of this
+            software for any purpose. It is provided solely "as is".
+ 
+ ===========================================================================
+ */
+ 
+ #ifndef __gpc_h
+ #define __gpc_h
+ 
+ #include <stdio.h>
+ 
+ 
+ /*
+ ===========================================================================
+                                Constants
+ ===========================================================================
+ */
+ 
+ /* Increase GPC_EPSILON to encourage merging of near coincident edges    */
+ 
+ #define GPC_EPSILON (DBL_EPSILON)
+ 
+ #define GPC_VERSION "2.32"
+ 
+ 
+ /*
+ ===========================================================================
+                            Public Data Types
+ ===========================================================================
+ */
+ 
+ typedef enum                        /* Set operation type                */
+ {
+   GPC_DIFF,                         /* Difference                        */
+   GPC_INT,                          /* Intersection                      */
+   GPC_XOR,                          /* Exclusive or                      */
+   GPC_UNION                         /* Union                             */
+ } gpc_op;
+ 
+ typedef struct                      /* Polygon vertex structure          */
+ {
+   double              x;            /* Vertex x component                */
+   double              y;            /* vertex y component                */
+ } gpc_vertex;
+ 
+ typedef struct                      /* Vertex list structure             */
+ {
+   int                 num_vertices; /* Number of vertices in list        */
+   gpc_vertex         *vertex;       /* Vertex array pointer              */
+ } gpc_vertex_list;
+ 
+ typedef struct                      /* Polygon set structure             */
+ {
+   int                 num_contours; /* Number of contours in polygon     */
+   int                *hole;         /* Hole / external contour flags     */
+   gpc_vertex_list    *contour;      /* Contour array pointer             */
+ } gpc_polygon;
+ 
+ typedef struct                      /* Tristrip set structure            */
+ {
+   int                 num_strips;   /* Number of tristrips               */
+   gpc_vertex_list    *strip;        /* Tristrip array pointer            */
+ } gpc_tristrip;
+ 
+ 
+ /*
+ ===========================================================================
+                        Public Function Prototypes
+ ===========================================================================
+ */
+ 
+ void gpc_read_polygon        (FILE            *infile_ptr, 
+                               int              read_hole_flags,
+                               gpc_polygon     *polygon);
+ 
+ void gpc_write_polygon       (FILE            *outfile_ptr,
+                               int              write_hole_flags,
+                               gpc_polygon     *polygon);
+ 
+ void gpc_add_contour         (gpc_polygon     *polygon,
+                               gpc_vertex_list *contour,
+                               int              hole);
+ 
+ void gpc_polygon_clip        (gpc_op           set_operation,
+                               gpc_polygon     *subject_polygon,
+                               gpc_polygon     *clip_polygon,
+                               gpc_polygon     *result_polygon);
+ 
+ void gpc_tristrip_clip       (gpc_op           set_operation,
+                               gpc_polygon     *subject_polygon,
+                               gpc_polygon     *clip_polygon,
+                               gpc_tristrip    *result_tristrip);
+ 
+ void gpc_polygon_to_tristrip (gpc_polygon     *polygon,
+                               gpc_tristrip    *tristrip);
+ 
+ void gpc_free_polygon        (gpc_polygon     *polygon);
+ 
+ void gpc_free_tristrip       (gpc_tristrip    *tristrip);
+ 
+ #endif
+ 
+ /*
+ ===========================================================================
+                            End of file: gpc.h
+ ===========================================================================
+ */
*** ./i18npool/prj/build.lst.osr6	Thu Apr 24 04:54:37 2003
--- ./i18npool/prj/build.lst	Wed Oct 26 20:22:51 2005
***************
*** 1,4 ****
! inp  i18npool    :   bridges sax stoc comphelper tools icu i18nutil regexp NULL
  inp  i18npool                                   usr1    -   all inp_mkout NULL
  inp  i18npool\source\unotypes                   nmake   -   all inp_utypes NULL
  inp  i18npool\source\registerservices           nmake   -   all inp_rserv inp_utypes NULL
--- 1,4 ----
! inp  i18npool    :   bridges sax stoc comphelper tools i18nutil regexp NULL
  inp  i18npool                                   usr1    -   all inp_mkout NULL
  inp  i18npool\source\unotypes                   nmake   -   all inp_utypes NULL
  inp  i18npool\source\registerservices           nmake   -   all inp_rserv inp_utypes NULL
*** ./icu/icu-2.6.patch.osr6	Fri Aug 26 04:43:35 2005
--- ./icu/icu-2.6.patch	Wed Oct 26 22:54:34 2005
***************
*** 2747,2749 ****
--- 2747,4429 ----
        commands = pkg_appendToList(commands, NULL, uprv_strdup(stanza));
    
        sprintf(stanza, "@$(RMV) $(TEMP_DIR)/%s", cfile+genFileOffset);
+ --- misc/build/icu/source/config.guess.00	2001-10-18 19:30:44.000000000 -0700
+ +++ misc/build/icu/source/config.guess	2005-10-26 22:14:47.208174009 -0700
+ @@ -1,9 +1,9 @@
+  #! /bin/sh
+  # Attempt to guess a canonical system name.
+ -#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+ -#   Free Software Foundation, Inc.
+ +#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+ +#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+  
+ -timestamp='2001-09-04'
+ +timestamp='2005-09-19'
+  
+  # This file is free software; you can redistribute it and/or modify it
+  # under the terms of the GNU General Public License as published by
+ @@ -17,15 +17,18 @@
+  #
+  # You should have received a copy of the GNU General Public License
+  # along with this program; if not, write to the Free Software
+ -# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ +# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+ +# 02110-1301, USA.
+  #
+  # As a special exception to the GNU General Public License, if you
+  # distribute this file as part of a program that contains a
+  # configuration script generated by Autoconf, you may include it under
+  # the same distribution terms that you use for the rest of that program.
+  
+ -# Written by Per Bothner <bothner@cygnus.com>.
+ -# Please send patches to <config-patches@gnu.org>.
+ +
+ +# Originally written by Per Bothner <per@bothner.com>.
+ +# Please send patches to <config-patches@gnu.org>.  Submit a context
+ +# diff and a properly formatted ChangeLog entry.
+  #
+  # This script attempts to guess a canonical system name similar to
+  # config.sub.  If it succeeds, it prints the system name on stdout, and
+ @@ -52,7 +55,7 @@
+  GNU config.guess ($timestamp)
+  
+  Originally written by Per Bothner.
+ -Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+ +Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+  Free Software Foundation, Inc.
+  
+  This is free software; see the source for copying conditions.  There is NO
+ @@ -65,11 +68,11 @@
+  while test $# -gt 0 ; do
+    case $1 in
+      --time-stamp | --time* | -t )
+ -       echo "$timestamp" ; exit 0 ;;
+ +       echo "$timestamp" ; exit ;;
+      --version | -v )
+ -       echo "$version" ; exit 0 ;;
+ +       echo "$version" ; exit ;;
+      --help | --h* | -h )
+ -       echo "$usage"; exit 0 ;;
+ +       echo "$usage"; exit ;;
+      -- )     # Stop option processing
+         shift; break ;;
+      - )	# Use stdin as input.
+ @@ -87,30 +90,42 @@
+    exit 1
+  fi
+  
+ +trap 'exit 1' 1 2 15
+  
+ -dummy=dummy-$$
+ -trap 'rm -f $dummy.c $dummy.o $dummy.rel $dummy; exit 1' 1 2 15
+ +# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+ +# compiler to aid in system detection is discouraged as it requires
+ +# temporary files to be created and, as you can see below, it is a
+ +# headache to deal with in a portable fashion.
+  
+ -# CC_FOR_BUILD -- compiler used by this script.
+  # Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+  # use `HOST_CC' if defined, but it is deprecated.
+  
+ -set_cc_for_build='case $CC_FOR_BUILD,$HOST_CC,$CC in
+ - ,,)    echo "int dummy(){}" > $dummy.c ;
+ -	for c in cc gcc c89 ; do
+ -	  ($c $dummy.c -c -o $dummy.o) >/dev/null 2>&1 ;
+ -	  if test $? = 0 ; then
+ +# Portable tmp directory creation inspired by the Autoconf team.
+ +
+ +set_cc_for_build='
+ +trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+ +trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+ +: ${TMPDIR=/tmp} ;
+ + { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ + { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ + { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+ + { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+ +dummy=$tmp/dummy ;
+ +tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+ +case $CC_FOR_BUILD,$HOST_CC,$CC in
+ + ,,)    echo "int x;" > $dummy.c ;
+ +	for c in cc gcc c89 c99 ; do
+ +	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
+  	     CC_FOR_BUILD="$c"; break ;
+  	  fi ;
+  	done ;
+ -	rm -f $dummy.c $dummy.o $dummy.rel ;
+  	if test x"$CC_FOR_BUILD" = x ; then
+  	  CC_FOR_BUILD=no_compiler_found ;
+  	fi
+  	;;
+   ,,*)   CC_FOR_BUILD=$CC ;;
+   ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+ -esac'
+ +esac ; set_cc_for_build= ;'
+  
+  # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+  # (ghazi@noc.rutgers.edu 1994-08-24)
+ @@ -127,29 +142,30 @@
+  
+  case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+      *:NetBSD:*:*)
+ -	# Netbsd (nbsd) targets should (where applicable) match one or
+ +	# NetBSD (nbsd) targets should (where applicable) match one or
+  	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+  	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+  	# switched to ELF, *-*-netbsd* would select the old
+  	# object file format.  This provides both forward
+  	# compatibility and a consistent mechanism for selecting the
+  	# object file format.
+ -	# Determine the machine/vendor (is the vendor relevant).
+ -	case "${UNAME_MACHINE}" in
+ -	    amiga) machine=m68k-unknown ;;
+ -	    arm32) machine=arm-unknown ;;
+ -	    atari*) machine=m68k-atari ;;
+ -	    sun3*) machine=m68k-sun ;;
+ -	    mac68k) machine=m68k-apple ;;
+ -	    macppc) machine=powerpc-apple ;;
+ -	    hp3[0-9][05]) machine=m68k-hp ;;
+ -	    ibmrt|romp-ibm) machine=romp-ibm ;;
+ -	    *) machine=${UNAME_MACHINE}-unknown ;;
+ +	#
+ +	# Note: NetBSD doesn't particularly care about the vendor
+ +	# portion of the name.  We always set it to "unknown".
+ +	sysctl="sysctl -n hw.machine_arch"
+ +	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
+ +	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+ +	case "${UNAME_MACHINE_ARCH}" in
+ +	    armeb) machine=armeb-unknown ;;
+ +	    arm*) machine=arm-unknown ;;
+ +	    sh3el) machine=shl-unknown ;;
+ +	    sh3eb) machine=sh-unknown ;;
+ +	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+  	esac
+  	# The Operating System including object format, if it has switched
+  	# to ELF recently, or will in the future.
+ -	case "${UNAME_MACHINE}" in
+ -	    i386|sparc|amiga|arm*|hp300|mvme68k|vax|atari|luna68k|mac68k|news68k|next68k|pc532|sun3*|x68k)
+ +	case "${UNAME_MACHINE_ARCH}" in
+ +	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+  		eval $set_cc_for_build
+  		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+  			| grep __ELF__ >/dev/null
+ @@ -166,120 +182,125 @@
+  		;;
+  	esac
+  	# The OS release
+ -	release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+ +	# Debian GNU/NetBSD machines have a different userland, and
+ +	# thus, need a distinct triplet. However, they do not need
+ +	# kernel version information, so it can be replaced with a
+ +	# suitable tag, in the style of linux-gnu.
+ +	case "${UNAME_VERSION}" in
+ +	    Debian*)
+ +		release='-gnu'
+ +		;;
+ +	    *)
+ +		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+ +		;;
+ +	esac
+  	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+  	# contains redundant information, the shorter form:
+  	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+  	echo "${machine}-${os}${release}"
+ -	exit 0 ;;
+ +	exit ;;
+ +    *:OpenBSD:*:*)
+ +	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+ +	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+ +	exit ;;
+ +    *:ekkoBSD:*:*)
+ +	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+ +	exit ;;
+ +    macppc:MirBSD:*:*)
+ +	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
+ +	exit ;;
+ +    *:MirBSD:*:*)
+ +	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+ +	exit ;;
+      alpha:OSF1:*:*)
+ -	if test $UNAME_RELEASE = "V4.0"; then
+ +	case $UNAME_RELEASE in
+ +	*4.0)
+  		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+ -	fi
+ +		;;
+ +	*5.*)
+ +	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+ +		;;
+ +	esac
+ +	# According to Compaq, /usr/sbin/psrinfo has been available on
+ +	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+ +	# covers most systems running today.  This code pipes the CPU
+ +	# types through head -n 1, so we only detect the type of CPU 0.
+ +	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+ +	case "$ALPHA_CPU_TYPE" in
+ +	    "EV4 (21064)")
+ +		UNAME_MACHINE="alpha" ;;
+ +	    "EV4.5 (21064)")
+ +		UNAME_MACHINE="alpha" ;;
+ +	    "LCA4 (21066/21068)")
+ +		UNAME_MACHINE="alpha" ;;
+ +	    "EV5 (21164)")
+ +		UNAME_MACHINE="alphaev5" ;;
+ +	    "EV5.6 (21164A)")
+ +		UNAME_MACHINE="alphaev56" ;;
+ +	    "EV5.6 (21164PC)")
+ +		UNAME_MACHINE="alphapca56" ;;
+ +	    "EV5.7 (21164PC)")
+ +		UNAME_MACHINE="alphapca57" ;;
+ +	    "EV6 (21264)")
+ +		UNAME_MACHINE="alphaev6" ;;
+ +	    "EV6.7 (21264A)")
+ +		UNAME_MACHINE="alphaev67" ;;
+ +	    "EV6.8CB (21264C)")
+ +		UNAME_MACHINE="alphaev68" ;;
+ +	    "EV6.8AL (21264B)")
+ +		UNAME_MACHINE="alphaev68" ;;
+ +	    "EV6.8CX (21264D)")
+ +		UNAME_MACHINE="alphaev68" ;;
+ +	    "EV6.9A (21264/EV69A)")
+ +		UNAME_MACHINE="alphaev69" ;;
+ +	    "EV7 (21364)")
+ +		UNAME_MACHINE="alphaev7" ;;
+ +	    "EV7.9 (21364A)")
+ +		UNAME_MACHINE="alphaev79" ;;
+ +	esac
+ +	# A Pn.n version is a patched version.
+  	# A Vn.n version is a released version.
+  	# A Tn.n version is a released field test version.
+  	# A Xn.n version is an unreleased experimental baselevel.
+  	# 1.2 uses "1.2" for uname -r.
+ -	cat <<EOF >$dummy.s
+ -	.data
+ -\$Lformat:
+ -	.byte 37,100,45,37,120,10,0	# "%d-%x\n"
+ -
+ -	.text
+ -	.globl main
+ -	.align 4
+ -	.ent main
+ -main:
+ -	.frame \$30,16,\$26,0
+ -	ldgp \$29,0(\$27)
+ -	.prologue 1
+ -	.long 0x47e03d80 # implver \$0
+ -	lda \$2,-1
+ -	.long 0x47e20c21 # amask \$2,\$1
+ -	lda \$16,\$Lformat
+ -	mov \$0,\$17
+ -	not \$1,\$18
+ -	jsr \$26,printf
+ -	ldgp \$29,0(\$26)
+ -	mov 0,\$16
+ -	jsr \$26,exit
+ -	.end main
+ -EOF
+ -	eval $set_cc_for_build
+ -	$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null
+ -	if test "$?" = 0 ; then
+ -		case `./$dummy` in
+ -			0-0)
+ -				UNAME_MACHINE="alpha"
+ -				;;
+ -			1-0)
+ -				UNAME_MACHINE="alphaev5"
+ -				;;
+ -			1-1)
+ -				UNAME_MACHINE="alphaev56"
+ -				;;
+ -			1-101)
+ -				UNAME_MACHINE="alphapca56"
+ -				;;
+ -			2-303)
+ -				UNAME_MACHINE="alphaev6"
+ -				;;
+ -			2-307)
+ -				UNAME_MACHINE="alphaev67"
+ -				;;
+ -			2-1307)
+ -				UNAME_MACHINE="alphaev68"
+ -				;;
+ -		esac
+ -	fi
+ -	rm -f $dummy.s $dummy
+ -	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+ -	exit 0 ;;
+ +	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+ +	exit ;;
+      Alpha\ *:Windows_NT*:*)
+  	# How do we know it's Interix rather than the generic POSIX subsystem?
+  	# Should we change UNAME_MACHINE based on the output of uname instead
+  	# of the specific Alpha model?
+  	echo alpha-pc-interix
+ -	exit 0 ;;
+ +	exit ;;
+      21064:Windows_NT:50:3)
+  	echo alpha-dec-winnt3.5
+ -	exit 0 ;;
+ +	exit ;;
+      Amiga*:UNIX_System_V:4.0:*)
+  	echo m68k-unknown-sysv4
+ -	exit 0;;
+ -    amiga:OpenBSD:*:*)
+ -	echo m68k-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      *:[Aa]miga[Oo][Ss]:*:*)
+  	echo ${UNAME_MACHINE}-unknown-amigaos
+ -	exit 0 ;;
+ -    arc64:OpenBSD:*:*)
+ -	echo mips64el-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    arc:OpenBSD:*:*)
+ -	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    hkmips:OpenBSD:*:*)
+ -	echo mips-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    pmax:OpenBSD:*:*)
+ -	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    sgi:OpenBSD:*:*)
+ -	echo mips-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    wgrisc:OpenBSD:*:*)
+ -	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+ +    *:[Mm]orph[Oo][Ss]:*:*)
+ +	echo ${UNAME_MACHINE}-unknown-morphos
+ +	exit ;;
+      *:OS/390:*:*)
+  	echo i370-ibm-openedition
+ -	exit 0 ;;
+ +	exit ;;
+ +    *:z/VM:*:*)
+ +	echo s390-ibm-zvmoe
+ +	exit ;;
+ +    *:OS400:*:*)
+ +        echo powerpc-ibm-os400
+ +	exit ;;
+      arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+  	echo arm-acorn-riscix${UNAME_RELEASE}
+ -	exit 0;;
+ +	exit ;;
+ +    arm:riscos:*:*|arm:RISCOS:*:*)
+ +	echo arm-unknown-riscos
+ +	exit ;;
+      SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+  	echo hppa1.1-hitachi-hiuxmpp
+ -	exit 0;;
+ +	exit ;;
+      Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+  	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+  	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+ @@ -287,25 +308,32 @@
+  	else
+  		echo pyramid-pyramid-bsd
+  	fi
+ -	exit 0 ;;
+ +	exit ;;
+      NILE*:*:*:dcosx)
+  	echo pyramid-pyramid-svr4
+ -	exit 0 ;;
+ +	exit ;;
+ +    DRS?6000:unix:4.0:6*)
+ +	echo sparc-icl-nx6
+ +	exit ;;
+ +    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+ +	case `/usr/bin/uname -p` in
+ +	    sparc) echo sparc-icl-nx7; exit ;;
+ +	esac ;;
+      sun4H:SunOS:5.*:*)
+  	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+ -	exit 0 ;;
+ +	exit ;;
+      sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+  	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+ -	exit 0 ;;
+ +	exit ;;
+      i86pc:SunOS:5.*:*)
+  	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+ -	exit 0 ;;
+ +	exit ;;
+      sun4*:SunOS:6*:*)
+  	# According to config.sub, this is the proper way to canonicalize
+  	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+  	# it's likely to be more like Solaris than SunOS4.
+  	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+ -	exit 0 ;;
+ +	exit ;;
+      sun4*:SunOS:*:*)
+  	case "`/usr/bin/arch -k`" in
+  	    Series*|S4*)
+ @@ -314,12 +342,12 @@
+  	esac
+  	# Japanese Language versions have a version number like `4.1.3-JL'.
+  	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+ -	exit 0 ;;
+ +	exit ;;
+      sun3*:SunOS:*:*)
+  	echo m68k-sun-sunos${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      sun*:*:4.2BSD:*)
+ -	UNAME_RELEASE=`(head -1 /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+ +	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+  	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+  	case "`/bin/arch`" in
+  	    sun3)
+ @@ -329,16 +357,10 @@
+  		echo sparc-sun-sunos${UNAME_RELEASE}
+  		;;
+  	esac
+ -	exit 0 ;;
+ +	exit ;;
+      aushp:SunOS:*:*)
+  	echo sparc-auspex-sunos${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    sparc*:NetBSD:*)
+ -	echo `uname -p`-unknown-netbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    atari*:OpenBSD:*:*)
+ -	echo m68k-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      # The situation for MiNT is a little confusing.  The machine name
+      # can be virtually everything (everything which is not
+      # "atarist" or "atariste" at least should have a processor
+ @@ -349,49 +371,40 @@
+      # be no problem.
+      atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+          echo m68k-atari-mint${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+  	echo m68k-atari-mint${UNAME_RELEASE}
+ -        exit 0 ;;
+ +        exit ;;
+      *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+          echo m68k-atari-mint${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+          echo m68k-milan-mint${UNAME_RELEASE}
+ -        exit 0 ;;
+ +        exit ;;
+      hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+          echo m68k-hades-mint${UNAME_RELEASE}
+ -        exit 0 ;;
+ +        exit ;;
+      *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+          echo m68k-unknown-mint${UNAME_RELEASE}
+ -        exit 0 ;;
+ -    sun3*:OpenBSD:*:*)
+ -	echo m68k-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    mac68k:OpenBSD:*:*)
+ -	echo m68k-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    mvme68k:OpenBSD:*:*)
+ -	echo m68k-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ -    mvme88k:OpenBSD:*:*)
+ -	echo m88k-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ +        exit ;;
+ +    m68k:machten:*:*)
+ +	echo m68k-apple-machten${UNAME_RELEASE}
+ +	exit ;;
+      powerpc:machten:*:*)
+  	echo powerpc-apple-machten${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      RISC*:Mach:*:*)
+  	echo mips-dec-mach_bsd4.3
+ -	exit 0 ;;
+ +	exit ;;
+      RISC*:ULTRIX:*:*)
+  	echo mips-dec-ultrix${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      VAX*:ULTRIX*:*:*)
+  	echo vax-dec-ultrix${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      2020:CLIX:*:* | 2430:CLIX:*:*)
+  	echo clipper-intergraph-clix${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      mips:*:*:UMIPS | mips:*:*:RISCos)
+  	eval $set_cc_for_build
+  	sed 's/^	//' << EOF >$dummy.c
+ @@ -415,27 +428,33 @@
+  	  exit (-1);
+  	}
+  EOF
+ -	$CC_FOR_BUILD $dummy.c -o $dummy \
+ -	  && ./$dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
+ -	  && rm -f $dummy.c $dummy && exit 0
+ -	rm -f $dummy.c $dummy
+ +	$CC_FOR_BUILD -o $dummy $dummy.c &&
+ +	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+ +	  SYSTEM_NAME=`$dummy $dummyarg` &&
+ +	    { echo "$SYSTEM_NAME"; exit; }
+  	echo mips-mips-riscos${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      Motorola:PowerMAX_OS:*:*)
+  	echo powerpc-motorola-powermax
+ -	exit 0 ;;
+ +	exit ;;
+ +    Motorola:*:4.3:PL8-*)
+ +	echo powerpc-harris-powermax
+ +	exit ;;
+ +    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+ +	echo powerpc-harris-powermax
+ +	exit ;;
+      Night_Hawk:Power_UNIX:*:*)
+  	echo powerpc-harris-powerunix
+ -	exit 0 ;;
+ +	exit ;;
+      m88k:CX/UX:7*:*)
+  	echo m88k-harris-cxux7
+ -	exit 0 ;;
+ +	exit ;;
+      m88k:*:4*:R4*)
+  	echo m88k-motorola-sysv4
+ -	exit 0 ;;
+ +	exit ;;
+      m88k:*:3*:R3*)
+  	echo m88k-motorola-sysv3
+ -	exit 0 ;;
+ +	exit ;;
+      AViiON:dgux:*:*)
+          # DG/UX returns AViiON for all architectures
+          UNAME_PROCESSOR=`/usr/bin/uname -p`
+ @@ -451,29 +470,29 @@
+  	else
+  	    echo i586-dg-dgux${UNAME_RELEASE}
+  	fi
+ - 	exit 0 ;;
+ + 	exit ;;
+      M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+  	echo m88k-dolphin-sysv3
+ -	exit 0 ;;
+ +	exit ;;
+      M88*:*:R3*:*)
+  	# Delta 88k system running SVR3
+  	echo m88k-motorola-sysv3
+ -	exit 0 ;;
+ +	exit ;;
+      XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+  	echo m88k-tektronix-sysv3
+ -	exit 0 ;;
+ +	exit ;;
+      Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+  	echo m68k-tektronix-bsd
+ -	exit 0 ;;
+ +	exit ;;
+      *:IRIX*:*:*)
+  	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+ -	exit 0 ;;
+ +	exit ;;
+      ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+ -	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
+ -	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+ +	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+ +	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+      i*86:AIX:*:*)
+  	echo i386-ibm-aix
+ -	exit 0 ;;
+ +	exit ;;
+      ia64:AIX:*:*)
+  	if [ -x /usr/bin/oslevel ] ; then
+  		IBM_REV=`/usr/bin/oslevel`
+ @@ -481,7 +500,7 @@
+  		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+  	fi
+  	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+ -	exit 0 ;;
+ +	exit ;;
+      *:AIX:2:3)
+  	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+  		eval $set_cc_for_build
+ @@ -496,17 +515,20 @@
+  			exit(0);
+  			}
+  EOF
+ -		$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm -f $dummy.c $dummy && exit 0
+ -		rm -f $dummy.c $dummy
+ -		echo rs6000-ibm-aix3.2.5
+ +		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+ +		then
+ +			echo "$SYSTEM_NAME"
+ +		else
+ +			echo rs6000-ibm-aix3.2.5
+ +		fi
+  	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+  		echo rs6000-ibm-aix3.2.4
+  	else
+  		echo rs6000-ibm-aix3.2
+  	fi
+ -	exit 0 ;;
+ +	exit ;;
+      *:AIX:*:[45])
+ -	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -1 | awk '{ print $1 }'`
+ +	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+  	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+  		IBM_ARCH=rs6000
+  	else
+ @@ -518,38 +540,36 @@
+  		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+  	fi
+  	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+ -	exit 0 ;;
+ +	exit ;;
+      *:AIX:*:*)
+  	echo rs6000-ibm-aix
+ -	exit 0 ;;
+ +	exit ;;
+      ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+  	echo romp-ibm-bsd4.4
+ -	exit 0 ;;
+ +	exit ;;
+      ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+  	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+ -	exit 0 ;;                           # report: romp-ibm BSD 4.3
+ +	exit ;;                             # report: romp-ibm BSD 4.3
+      *:BOSX:*:*)
+  	echo rs6000-bull-bosx
+ -	exit 0 ;;
+ +	exit ;;
+      DPX/2?00:B.O.S.:*:*)
+  	echo m68k-bull-sysv3
+ -	exit 0 ;;
+ +	exit ;;
+      9000/[34]??:4.3bsd:1.*:*)
+  	echo m68k-hp-bsd
+ -	exit 0 ;;
+ +	exit ;;
+      hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+  	echo m68k-hp-bsd4.4
+ -	exit 0 ;;
+ +	exit ;;
+      9000/[34678]??:HP-UX:*:*)
+  	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+  	case "${UNAME_MACHINE}" in
+  	    9000/31? )            HP_ARCH=m68000 ;;
+  	    9000/[34]?? )         HP_ARCH=m68k ;;
+  	    9000/[678][0-9][0-9])
+ -              case "${HPUX_REV}" in
+ -                11.[0-9][0-9])
+ -                  if [ -x /usr/bin/getconf ]; then
+ -                    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+ +		if [ -x /usr/bin/getconf ]; then
+ +		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+                      sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+                      case "${sc_cpu_version}" in
+                        523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+ @@ -558,13 +578,13 @@
+                          case "${sc_kernel_bits}" in
+                            32) HP_ARCH="hppa2.0n" ;;
+                            64) HP_ARCH="hppa2.0w" ;;
+ +			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+                          esac ;;
+                      esac
+ -                  fi ;;
+ -              esac
+ -              if [ "${HP_ARCH}" = "" ]; then
+ -	      eval $set_cc_for_build
+ -              sed 's/^              //' << EOF >$dummy.c
+ +		fi
+ +		if [ "${HP_ARCH}" = "" ]; then
+ +		    eval $set_cc_for_build
+ +		    sed 's/^              //' << EOF >$dummy.c
+  
+                #define _HPUX_SOURCE
+                #include <stdlib.h>
+ @@ -597,17 +617,37 @@
+                    exit (0);
+                }
+  EOF
+ -	    (CCOPTS= $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null ) && HP_ARCH=`./$dummy`
+ -	    if test -z "$HP_ARCH"; then HP_ARCH=hppa; fi
+ -	    rm -f $dummy.c $dummy
+ -	fi ;;
+ +		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+ +		    test -z "$HP_ARCH" && HP_ARCH=hppa
+ +		fi ;;
+  	esac
+ +	if [ ${HP_ARCH} = "hppa2.0w" ]
+ +	then
+ +	    eval $set_cc_for_build
+ +
+ +	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+ +	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+ +	    # generating 64-bit code.  GNU and HP use different nomenclature:
+ +	    #
+ +	    # $ CC_FOR_BUILD=cc ./config.guess
+ +	    # => hppa2.0w-hp-hpux11.23
+ +	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+ +	    # => hppa64-hp-hpux11.23
+ +
+ +	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+ +		grep __LP64__ >/dev/null
+ +	    then
+ +		HP_ARCH="hppa2.0w"
+ +	    else
+ +		HP_ARCH="hppa64"
+ +	    fi
+ +	fi
+  	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+ -	exit 0 ;;
+ +	exit ;;
+      ia64:HP-UX:*:*)
+  	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+  	echo ia64-hp-hpux${HPUX_REV}
+ -	exit 0 ;;
+ +	exit ;;
+      3050*:HI-UX:*:*)
+  	eval $set_cc_for_build
+  	sed 's/^	//' << EOF >$dummy.c
+ @@ -635,158 +675,213 @@
+  	  exit (0);
+  	}
+  EOF
+ -	$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm -f $dummy.c $dummy && exit 0
+ -	rm -f $dummy.c $dummy
+ +	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+ +		{ echo "$SYSTEM_NAME"; exit; }
+  	echo unknown-hitachi-hiuxwe2
+ -	exit 0 ;;
+ +	exit ;;
+      9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+  	echo hppa1.1-hp-bsd
+ -	exit 0 ;;
+ +	exit ;;
+      9000/8??:4.3bsd:*:*)
+  	echo hppa1.0-hp-bsd
+ -	exit 0 ;;
+ +	exit ;;
+      *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+  	echo hppa1.0-hp-mpeix
+ -	exit 0 ;;
+ +	exit ;;
+      hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+  	echo hppa1.1-hp-osf
+ -	exit 0 ;;
+ +	exit ;;
+      hp8??:OSF1:*:*)
+  	echo hppa1.0-hp-osf
+ -	exit 0 ;;
+ +	exit ;;
+      i*86:OSF1:*:*)
+  	if [ -x /usr/sbin/sysversion ] ; then
+  	    echo ${UNAME_MACHINE}-unknown-osf1mk
+  	else
+  	    echo ${UNAME_MACHINE}-unknown-osf1
+  	fi
+ -	exit 0 ;;
+ +	exit ;;
+      parisc*:Lites*:*:*)
+  	echo hppa1.1-hp-lites
+ -	exit 0 ;;
+ -    hppa*:OpenBSD:*:*)
+ -	echo hppa-unknown-openbsd
+ -	exit 0 ;;
+ +	exit ;;
+      C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+  	echo c1-convex-bsd
+ -        exit 0 ;;
+ +        exit ;;
+      C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+  	if getsysinfo -f scalar_acc
+  	then echo c32-convex-bsd
+  	else echo c2-convex-bsd
+  	fi
+ -        exit 0 ;;
+ +        exit ;;
+      C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+  	echo c34-convex-bsd
+ -        exit 0 ;;
+ +        exit ;;
+      C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+  	echo c38-convex-bsd
+ -        exit 0 ;;
+ +        exit ;;
+      C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+  	echo c4-convex-bsd
+ -        exit 0 ;;
+ -    CRAY*X-MP:*:*:*)
+ -	echo xmp-cray-unicos
+ -        exit 0 ;;
+ +        exit ;;
+      CRAY*Y-MP:*:*:*)
+  	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+ -	exit 0 ;;
+ +	exit ;;
+      CRAY*[A-Z]90:*:*:*)
+  	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+  	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+  	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+  	      -e 's/\.[^.]*$/.X/'
+ -	exit 0 ;;
+ +	exit ;;
+      CRAY*TS:*:*:*)
+  	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+ -	exit 0 ;;
+ -    CRAY*T3D:*:*:*)
+ -	echo alpha-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+ -	exit 0 ;;
+ +	exit ;;
+      CRAY*T3E:*:*:*)
+  	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+ -	exit 0 ;;
+ +	exit ;;
+      CRAY*SV1:*:*:*)
+  	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+ -	exit 0 ;;
+ -    CRAY-2:*:*:*)
+ -	echo cray2-cray-unicos
+ -        exit 0 ;;
+ +	exit ;;
+ +    *:UNICOS/mp:*:*)
+ +	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+ +	exit ;;
+      F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+  	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+          FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+          FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+          echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+ -        exit 0 ;;
+ -    hp300:OpenBSD:*:*)
+ -	echo m68k-unknown-openbsd${UNAME_RELEASE}
+ -	exit 0 ;;
+ +        exit ;;
+ +    5000:UNIX_System_V:4.*:*)
+ +        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+ +        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+ +        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+ +	exit ;;
+      i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+  	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      sparc*:BSD/OS:*:*)
+  	echo sparc-unknown-bsdi${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      *:BSD/OS:*:*)
+  	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      *:FreeBSD:*:*)
+  	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+ -	exit 0 ;;
+ -    *:OpenBSD:*:*)
+ -	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+ -	exit 0 ;;
+ +	exit ;;
+      i*:CYGWIN*:*)
+  	echo ${UNAME_MACHINE}-pc-cygwin
+ -	exit 0 ;;
+ +	exit ;;
+      i*:MINGW*:*)
+  	echo ${UNAME_MACHINE}-pc-mingw32
+ -	exit 0 ;;
+ +	exit ;;
+ +    i*:windows32*:*)
+ +    	# uname -m includes "-pc" on this system.
+ +    	echo ${UNAME_MACHINE}-mingw32
+ +	exit ;;
+      i*:PW*:*)
+  	echo ${UNAME_MACHINE}-pc-pw32
+ -	exit 0 ;;
+ +	exit ;;
+ +    x86:Interix*:[34]*)
+ +	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
+ +	exit ;;
+ +    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+ +	echo i${UNAME_MACHINE}-pc-mks
+ +	exit ;;
+      i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+  	# How do we know it's Interix rather than the generic POSIX subsystem?
+  	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+  	# UNAME_MACHINE based on the output of uname instead of i386?
+ -	echo i386-pc-interix
+ -	exit 0 ;;
+ +	echo i586-pc-interix
+ +	exit ;;
+      i*:UWIN*:*)
+  	echo ${UNAME_MACHINE}-pc-uwin
+ -	exit 0 ;;
+ +	exit ;;
+ +    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+ +	echo x86_64-unknown-cygwin
+ +	exit ;;
+      p*:CYGWIN*:*)
+  	echo powerpcle-unknown-cygwin
+ -	exit 0 ;;
+ +	exit ;;
+      prep*:SunOS:5.*:*)
+  	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+ -	exit 0 ;;
+ +	exit ;;
+      *:GNU:*:*)
+ +	# the GNU system
+  	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+ -	exit 0 ;;
+ +	exit ;;
+ +    *:GNU/*:*:*)
+ +	# other systems with GNU libc and userland
+ +	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+ +	exit ;;
+      i*86:Minix:*:*)
+  	echo ${UNAME_MACHINE}-pc-minix
+ -	exit 0 ;;
+ +	exit ;;
+      arm*:Linux:*:*)
+  	echo ${UNAME_MACHINE}-unknown-linux-gnu
+ -	exit 0 ;;
+ +	exit ;;
+ +    cris:Linux:*:*)
+ +	echo cris-axis-linux-gnu
+ +	exit ;;
+ +    crisv32:Linux:*:*)
+ +	echo crisv32-axis-linux-gnu
+ +	exit ;;
+ +    frv:Linux:*:*)
+ +    	echo frv-unknown-linux-gnu
+ +	exit ;;
+      ia64:Linux:*:*)
+ -	echo ${UNAME_MACHINE}-unknown-linux
+ -	exit 0 ;;
+ +	echo ${UNAME_MACHINE}-unknown-linux-gnu
+ +	exit ;;
+ +    m32r*:Linux:*:*)
+ +	echo ${UNAME_MACHINE}-unknown-linux-gnu
+ +	exit ;;
+      m68*:Linux:*:*)
+  	echo ${UNAME_MACHINE}-unknown-linux-gnu
+ -	exit 0 ;;
+ +	exit ;;
+      mips:Linux:*:*)
+ -	case `sed -n '/^byte/s/^.*: \(.*\) endian/\1/p' < /proc/cpuinfo` in
+ -	  big)    echo mips-unknown-linux-gnu && exit 0 ;;
+ -	  little) echo mipsel-unknown-linux-gnu && exit 0 ;;
+ -	esac
+ +	eval $set_cc_for_build
+ +	sed 's/^	//' << EOF >$dummy.c
+ +	#undef CPU
+ +	#undef mips
+ +	#undef mipsel
+ +	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+ +	CPU=mipsel
+ +	#else
+ +	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+ +	CPU=mips
+ +	#else
+ +	CPU=
+ +	#endif
+ +	#endif
+ +EOF
+ +	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+ +	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+  	;;
+ +    mips64:Linux:*:*)
+ +	eval $set_cc_for_build
+ +	sed 's/^	//' << EOF >$dummy.c
+ +	#undef CPU
+ +	#undef mips64
+ +	#undef mips64el
+ +	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+ +	CPU=mips64el
+ +	#else
+ +	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+ +	CPU=mips64
+ +	#else
+ +	CPU=
+ +	#endif
+ +	#endif
+ +EOF
+ +	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+ +	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+ +	;;
+ +    or32:Linux:*:*)
+ +	echo or32-unknown-linux-gnu
+ +	exit ;;
+      ppc:Linux:*:*)
+  	echo powerpc-unknown-linux-gnu
+ -	exit 0 ;;
+ +	exit ;;
+      ppc64:Linux:*:*)
+  	echo powerpc64-unknown-linux-gnu
+ -	exit 0 ;;
+ +	exit ;;
+      alpha:Linux:*:*)
+  	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+  	  EV5)   UNAME_MACHINE=alphaev5 ;;
+ @@ -800,7 +895,7 @@
+  	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
+  	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+  	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+ -	exit 0 ;;
+ +	exit ;;
+      parisc:Linux:*:* | hppa:Linux:*:*)
+  	# Look for CPU level
+  	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+ @@ -808,27 +903,31 @@
+  	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+  	  *)    echo hppa-unknown-linux-gnu ;;
+  	esac
+ -	exit 0 ;;
+ +	exit ;;
+      parisc64:Linux:*:* | hppa64:Linux:*:*)
+  	echo hppa64-unknown-linux-gnu
+ -	exit 0 ;;
+ +	exit ;;
+      s390:Linux:*:* | s390x:Linux:*:*)
+  	echo ${UNAME_MACHINE}-ibm-linux
+ -	exit 0 ;;
+ +	exit ;;
+ +    sh64*:Linux:*:*)
+ +    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+ +	exit ;;
+      sh*:Linux:*:*)
+  	echo ${UNAME_MACHINE}-unknown-linux-gnu
+ -	exit 0 ;;
+ +	exit ;;
+      sparc:Linux:*:* | sparc64:Linux:*:*)
+  	echo ${UNAME_MACHINE}-unknown-linux-gnu
+ -	exit 0 ;;
+ +	exit ;;
+      x86_64:Linux:*:*)
+  	echo x86_64-unknown-linux-gnu
+ -	exit 0 ;;
+ +	exit ;;
+      i*86:Linux:*:*)
+  	# The BFD linker knows what the default object file format is, so
+  	# first see if it will tell us. cd to the root directory to prevent
+  	# problems with other programs or directories called `ld' in the path.
+ -	ld_supported_targets=`cd /; ld --help 2>&1 \
+ +	# Set LC_ALL=C to ensure ld outputs messages in English.
+ +	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
+  			 | sed -ne '/supported targets:/!d
+  				    s/[ 	][ 	]*/ /g
+  				    s/.*supported targets: *//
+ @@ -840,52 +939,54 @@
+  		;;
+  	  a.out-i386-linux)
+  		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
+ -		exit 0 ;;		
+ +		exit ;;
+  	  coff-i386)
+  		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
+ -		exit 0 ;;
+ +		exit ;;
+  	  "")
+  		# Either a pre-BFD a.out linker (linux-gnuoldld) or
+  		# one that does not give us useful --help.
+  		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
+ -		exit 0 ;;
+ +		exit ;;
+  	esac
+  	# Determine whether the default compiler is a.out or elf
+  	eval $set_cc_for_build
+ -	cat >$dummy.c <<EOF
+ -#include <features.h>
+ -#ifdef __cplusplus
+ -#include <stdio.h>  /* for printf() prototype */
+ -	int main (int argc, char *argv[]) {
+ -#else
+ -	int main (argc, argv) int argc; char *argv[]; {
+ -#endif
+ -#ifdef __ELF__
+ -# ifdef __GLIBC__
+ -#  if __GLIBC__ >= 2
+ -    printf ("%s-pc-linux-gnu\n", argv[1]);
+ -#  else
+ -    printf ("%s-pc-linux-gnulibc1\n", argv[1]);
+ -#  endif
+ -# else
+ -   printf ("%s-pc-linux-gnulibc1\n", argv[1]);
+ -# endif
+ -#else
+ -  printf ("%s-pc-linux-gnuaout\n", argv[1]);
+ -#endif
+ -  return 0;
+ -}
+ +	sed 's/^	//' << EOF >$dummy.c
+ +	#include <features.h>
+ +	#ifdef __ELF__
+ +	# ifdef __GLIBC__
+ +	#  if __GLIBC__ >= 2
+ +	LIBC=gnu
+ +	#  else
+ +	LIBC=gnulibc1
+ +	#  endif
+ +	# else
+ +	LIBC=gnulibc1
+ +	# endif
+ +	#else
+ +	#ifdef __INTEL_COMPILER
+ +	LIBC=gnu
+ +	#else
+ +	LIBC=gnuaout
+ +	#endif
+ +	#endif
+ +	#ifdef __dietlibc__
+ +	LIBC=dietlibc
+ +	#endif
+  EOF
+ -	$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm -f $dummy.c $dummy && exit 0
+ -	rm -f $dummy.c $dummy
+ -	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
+ +	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
+ +	test x"${LIBC}" != x && {
+ +		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+ +		exit
+ +	}
+ +	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
+  	;;
+      i*86:DYNIX/ptx:4*:*)
+  	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+  	# earlier versions are messed up and put the nodename in both
+  	# sysname and nodename.
+  	echo i386-sequent-sysv4
+ -	exit 0 ;;
+ +	exit ;;
+      i*86:UNIX_SV:4.2MP:2.*)
+          # Unixware is an offshoot of SVR4, but it has its own version
+          # number series starting with 2...
+ @@ -893,7 +994,27 @@
+  	# I just have to hope.  -- rms.
+          # Use sysv4.2uw... so that sysv4* matches it.
+  	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+ -	exit 0 ;;
+ +	exit ;;
+ +    i*86:OS/2:*:*)
+ +	# If we were able to find `uname', then EMX Unix compatibility
+ +	# is probably installed.
+ +	echo ${UNAME_MACHINE}-pc-os2-emx
+ +	exit ;;
+ +    i*86:XTS-300:*:STOP)
+ +	echo ${UNAME_MACHINE}-unknown-stop
+ +	exit ;;
+ +    i*86:atheos:*:*)
+ +	echo ${UNAME_MACHINE}-unknown-atheos
+ +	exit ;;
+ +    i*86:syllable:*:*)
+ +	echo ${UNAME_MACHINE}-pc-syllable
+ +	exit ;;
+ +    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+ +	echo i386-unknown-lynxos${UNAME_RELEASE}
+ +	exit ;;
+ +    i*86:*DOS:*:*)
+ +	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+ +	exit ;;
+      i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+  	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+  	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+ @@ -901,99 +1022,100 @@
+  	else
+  		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+  	fi
+ -	exit 0 ;;
+ -    i*86:*:5:[78]*)
+ +	exit ;;
+ +    i*86:*:5:[678]*)
+ +    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+  	case `/bin/uname -X | grep "^Machine"` in
+  	    *486*)	     UNAME_MACHINE=i486 ;;
+  	    *Pentium)	     UNAME_MACHINE=i586 ;;
+  	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+  	esac
+  	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+ -	exit 0 ;;
+ +	exit ;;
+      i*86:*:3.2:*)
+  	if test -f /usr/options/cb.name; then
+  		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+  		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+  	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+ -		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
+ -		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
+ -		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
+ +		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+ +		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+ +		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+  			&& UNAME_MACHINE=i586
+ -		(/bin/uname -X|egrep '^Machine.*Pent ?II' >/dev/null) \
+ +		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+  			&& UNAME_MACHINE=i686
+ -		(/bin/uname -X|egrep '^Machine.*Pentium Pro' >/dev/null) \
+ +		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+  			&& UNAME_MACHINE=i686
+  		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+  	else
+  		echo ${UNAME_MACHINE}-pc-sysv32
+  	fi
+ -	exit 0 ;;
+ -    i*86:*DOS:*:*)
+ -	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+ -	exit 0 ;;
+ +	exit ;;
+      pc:*:*:*)
+  	# Left here for compatibility:
+          # uname -m prints for DJGPP always 'pc', but it prints nothing about
+          # the processor, so we play safe by assuming i386.
+  	echo i386-pc-msdosdjgpp
+ -        exit 0 ;;
+ +        exit ;;
+      Intel:Mach:3*:*)
+  	echo i386-pc-mach3
+ -	exit 0 ;;
+ +	exit ;;
+      paragon:*:*:*)
+  	echo i860-intel-osf1
+ -	exit 0 ;;
+ +	exit ;;
+      i860:*:4.*:*) # i860-SVR4
+  	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+  	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+  	else # Add other i860-SVR4 vendors below as they are discovered.
+  	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+  	fi
+ -	exit 0 ;;
+ +	exit ;;
+      mini*:CTIX:SYS*5:*)
+  	# "miniframe"
+  	echo m68010-convergent-sysv
+ -	exit 0 ;;
+ -    M68*:*:R3V[567]*:*)
+ -	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
+ -    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)
+ +	exit ;;
+ +    mc68k:UNIX:SYSTEM5:3.51m)
+ +	echo m68k-convergent-sysv
+ +	exit ;;
+ +    M680?0:D-NIX:5.3:*)
+ +	echo m68k-diab-dnix
+ +	exit ;;
+ +    M68*:*:R3V[5678]*:*)
+ +	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+ +    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+  	OS_REL=''
+  	test -r /etc/.relid \
+  	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+  	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+ -	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+ +	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+  	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+ -	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+ +	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+      3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+          /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+ -          && echo i486-ncr-sysv4 && exit 0 ;;
+ +          && { echo i486-ncr-sysv4; exit; } ;;
+      m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+  	echo m68k-unknown-lynxos${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      mc68030:UNIX_System_V:4.*:*)
+  	echo m68k-atari-sysv4
+ -	exit 0 ;;
+ -    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+ -	echo i386-unknown-lynxos${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      TSUNAMI:LynxOS:2.*:*)
+  	echo sparc-unknown-lynxos${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      rs6000:LynxOS:2.*:*)
+  	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+  	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      SM[BE]S:UNIX_SV:*:*)
+  	echo mips-dde-sysv${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      RM*:ReliantUNIX-*:*:*)
+  	echo mips-sni-sysv4
+ -	exit 0 ;;
+ +	exit ;;
+      RM*:SINIX-*:*:*)
+  	echo mips-sni-sysv4
+ -	exit 0 ;;
+ +	exit ;;
+      *:SINIX-*:*:*)
+  	if uname -p 2>/dev/null >/dev/null ; then
+  		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+ @@ -1001,82 +1123,98 @@
+  	else
+  		echo ns32k-sni-sysv
+  	fi
+ -	exit 0 ;;
+ +	exit ;;
+      PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                        # says <Richard.M.Bartel@ccMail.Census.GOV>
+          echo i586-unisys-sysv4
+ -        exit 0 ;;
+ +        exit ;;
+      *:UNIX_System_V:4*:FTX*)
+  	# From Gerald Hewes <hewes@openmarket.com>.
+  	# How about differentiating between stratus architectures? -djm
+  	echo hppa1.1-stratus-sysv4
+ -	exit 0 ;;
+ +	exit ;;
+      *:*:*:FTX*)
+  	# From seanf@swdc.stratus.com.
+  	echo i860-stratus-sysv4
+ -	exit 0 ;;
+ +	exit ;;
+ +    i*86:VOS:*:*)
+ +	# From Paul.Green@stratus.com.
+ +	echo ${UNAME_MACHINE}-stratus-vos
+ +	exit ;;
+      *:VOS:*:*)
+  	# From Paul.Green@stratus.com.
+  	echo hppa1.1-stratus-vos
+ -	exit 0 ;;
+ +	exit ;;
+      mc68*:A/UX:*:*)
+  	echo m68k-apple-aux${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      news*:NEWS-OS:6*:*)
+  	echo mips-sony-newsos6
+ -	exit 0 ;;
+ +	exit ;;
+      R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+  	if [ -d /usr/nec ]; then
+  	        echo mips-nec-sysv${UNAME_RELEASE}
+  	else
+  	        echo mips-unknown-sysv${UNAME_RELEASE}
+  	fi
+ -        exit 0 ;;
+ +        exit ;;
+      BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+  	echo powerpc-be-beos
+ -	exit 0 ;;
+ +	exit ;;
+      BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+  	echo powerpc-apple-beos
+ -	exit 0 ;;
+ +	exit ;;
+      BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+  	echo i586-pc-beos
+ -	exit 0 ;;
+ +	exit ;;
+      SX-4:SUPER-UX:*:*)
+  	echo sx4-nec-superux${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      SX-5:SUPER-UX:*:*)
+  	echo sx5-nec-superux${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+ +    SX-6:SUPER-UX:*:*)
+ +	echo sx6-nec-superux${UNAME_RELEASE}
+ +	exit ;;
+      Power*:Rhapsody:*:*)
+  	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      *:Rhapsody:*:*)
+  	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      *:Darwin:*:*)
+ -	echo `uname -p`-apple-darwin${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+ +	case $UNAME_PROCESSOR in
+ +	    unknown) UNAME_PROCESSOR=powerpc ;;
+ +	esac
+ +	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+ +	exit ;;
+      *:procnto*:*:* | *:QNX:[0123456789]*:*)
+ -	if test "${UNAME_MACHINE}" = "x86pc"; then
+ +	UNAME_PROCESSOR=`uname -p`
+ +	if test "$UNAME_PROCESSOR" = "x86"; then
+ +		UNAME_PROCESSOR=i386
+  		UNAME_MACHINE=pc
+  	fi
+ -	echo `uname -p`-${UNAME_MACHINE}-nto-qnx
+ -	exit 0 ;;
+ +	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+ +	exit ;;
+      *:QNX:*:4*)
+  	echo i386-pc-qnx
+ -	exit 0 ;;
+ -    NSR-[KW]:NONSTOP_KERNEL:*:*)
+ +	exit ;;
+ +    NSE-?:NONSTOP_KERNEL:*:*)
+ +	echo nse-tandem-nsk${UNAME_RELEASE}
+ +	exit ;;
+ +    NSR-?:NONSTOP_KERNEL:*:*)
+  	echo nsr-tandem-nsk${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      *:NonStop-UX:*:*)
+  	echo mips-compaq-nonstopux
+ -	exit 0 ;;
+ +	exit ;;
+      BS2000:POSIX*:*:*)
+  	echo bs2000-siemens-sysv
+ -	exit 0 ;;
+ +	exit ;;
+      DS/*:UNIX_System_V:*:*)
+  	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+ -	exit 0 ;;
+ +	exit ;;
+      *:Plan9:*:*)
+  	# "uname -m" is not consistent, so use $cputype instead. 386
+  	# is converted to i386 for consistency with other x86
+ @@ -1087,36 +1225,44 @@
+  	    UNAME_MACHINE="$cputype"
+  	fi
+  	echo ${UNAME_MACHINE}-unknown-plan9
+ -	exit 0 ;;
+ -    i*86:OS/2:*:*)
+ -	# If we were able to find `uname', then EMX Unix compatibility
+ -	# is probably installed.
+ -	echo ${UNAME_MACHINE}-pc-os2-emx
+ -	exit 0 ;;
+ +	exit ;;
+      *:TOPS-10:*:*)
+  	echo pdp10-unknown-tops10
+ -	exit 0 ;;
+ +	exit ;;
+      *:TENEX:*:*)
+  	echo pdp10-unknown-tenex
+ -	exit 0 ;;
+ +	exit ;;
+      KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+  	echo pdp10-dec-tops20
+ -	exit 0 ;;
+ +	exit ;;
+      XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+  	echo pdp10-xkl-tops20
+ -	exit 0 ;;
+ +	exit ;;
+      *:TOPS-20:*:*)
+  	echo pdp10-unknown-tops20
+ -	exit 0 ;;
+ +	exit ;;
+      *:ITS:*:*)
+  	echo pdp10-unknown-its
+ -	exit 0 ;;
+ -    i*86:XTS-300:*:STOP)
+ -	echo ${UNAME_MACHINE}-unknown-stop
+ -	exit 0 ;;
+ -    i*86:atheos:*:*)
+ -	echo ${UNAME_MACHINE}-unknown-atheos
+ -	exit 0 ;;
+ +	exit ;;
+ +    SEI:*:*:SEIUX)
+ +        echo mips-sei-seiux${UNAME_RELEASE}
+ +	exit ;;
+ +    *:DragonFly:*:*)
+ +	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+ +	exit ;;
+ +    *:*VMS:*:*)
+ +    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+ +	case "${UNAME_MACHINE}" in
+ +	    A*) echo alpha-dec-vms ; exit ;;
+ +	    I*) echo ia64-dec-vms ; exit ;;
+ +	    V*) echo vax-dec-vms ; exit ;;
+ +	esac ;;
+ +    *:XENIX:*:SysV)
+ +	echo i386-pc-xenix
+ +	exit ;;
+ +    i*86:skyos:*:*)
+ +	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+ +	exit ;;
+  esac
+  
+  #echo '(No uname command or uname output not recognized.)' 1>&2
+ @@ -1148,7 +1294,7 @@
+  #endif
+  
+  #if defined (__arm) && defined (__acorn) && defined (__unix)
+ -  printf ("arm-acorn-riscix"); exit (0);
+ +  printf ("arm-acorn-riscix\n"); exit (0);
+  #endif
+  
+  #if defined (hp300) && !defined (hpux)
+ @@ -1237,12 +1383,12 @@
+  }
+  EOF
+  
+ -$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm -f $dummy.c $dummy && exit 0
+ -rm -f $dummy.c $dummy
+ +$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+ +	{ echo "$SYSTEM_NAME"; exit; }
+  
+  # Apollos put the system type in the environment.
+  
+ -test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+ +test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+  
+  # Convex versions that predate uname can use getsysinfo(1)
+  
+ @@ -1251,22 +1397,22 @@
+      case `getsysinfo -f cpu_type` in
+      c1*)
+  	echo c1-convex-bsd
+ -	exit 0 ;;
+ +	exit ;;
+      c2*)
+  	if getsysinfo -f scalar_acc
+  	then echo c32-convex-bsd
+  	else echo c2-convex-bsd
+  	fi
+ -	exit 0 ;;
+ +	exit ;;
+      c34*)
+  	echo c34-convex-bsd
+ -	exit 0 ;;
+ +	exit ;;
+      c38*)
+  	echo c38-convex-bsd
+ -	exit 0 ;;
+ +	exit ;;
+      c4*)
+  	echo c4-convex-bsd
+ -	exit 0 ;;
+ +	exit ;;
+      esac
+  fi
+  
+ @@ -1277,7 +1423,9 @@
+  the operating system you are using. It is advised that you
+  download the most up to date version of the config scripts from
+  
+ -    ftp://ftp.gnu.org/pub/gnu/config/
+ +  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
+ +and
+ +  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
+  
+  If the version you run ($0) is already up to date, please
+  send the following data and any information you think might be
+ --- misc/build/icu/source/config/mh-unknown.00	2003-02-06 15:42:40.000000000 -0800
+ +++ misc/build/icu/source/config/mh-unknown	2005-10-26 22:35:01.450974002 -0700
+ @@ -1,27 +1,79 @@
+  ## -*-makefile-*-
+ -## Copyright (c) 2003, International Business Machines Corporation and
+ +## Based on Solaris-specific setup using Sun's workshop compilers
+ +## Copyright (c) 1999-2000, International Business Machines Corporation and
+  ## others. All Rights Reserved.
+  ##
+ +## $Id: mh-solaris,v 1.30 2002/07/30 02:46:10 grhoten-oss Exp $
+  
+ -# Note, this is not a real mh- file. You got here because configure
+ -# (specifically, aclocal.m4) could not determine a suitable mh- file.
+ -#
+ -# Perhaps your platform wasn't detected- try changing aclocal.m4 and
+ -# re-running autoconf. 
+ -#
+ -# If your platform is truly new/different:
+ -# As a start, try copying mh-linux (which is fairly generic) over this
+ -# file, and re-run config.status.
+ -
+ -%.$(STATIC_O) %.o %.$(STATIC_O) %.o ../data/%.o %.d %.d %.$(SO).$(SO_TARGET_VERSION_MAJOR) %.$(SO):
+ -	@echo 
+ -	@echo 
+ -	@echo "*** ERROR - configure could not detect your platform"
+ -	@echo "*** see the readme.html"
+ -	@echo "*** or, try copying icu/source/config/mh-linux to mh-unknown"
+ -	@echo "***   and editing it."
+ -	@echo 
+ -	@echo 
+ -	exit 1
+ +## Flags for position independent code
+ +SHAREDLIBCFLAGS = -KPIC
+ +SHAREDLIBCXXFLAGS = -KPIC
+ +SHAREDLIBCPPFLAGS = -DPIC
+  
+ +## Commands to generate dependency files
+ +GEN_DEPS.c=  $(CC) -xM $(DEFS) $(CPPFLAGS)
+ +GEN_DEPS.cc= $(CXX) -xM $(DEFS) $(CPPFLAGS)
+  
+ +# -mt means 'compiles and links a multithreaded program'
+ +CFLAGS += -Kpthread
+ +CXXFLAGS += -Kpthread
+ +
+ +## Commands to link
+ +LINK.c=		$(CXX) $(CXXFLAGS) $(LDFLAGS)
+ +LINK.cc=	$(CXX) $(CXXFLAGS) $(LDFLAGS)
+ +
+ +## Commands to make a shared library
+ +SHLIB.c=	$(CC) $(CFLAGS) $(LDFLAGS) -G
+ +SHLIB.cc=	$(CXX) $(CXXFLAGS) $(LDFLAGS) -G
+ +
+ +## Compiler switch to embed a runtime search path
+ +#LD_RPATH= -R
+ +#LD_RPATH_PRE=	
+ +
+ +## Force RPATH=$ORIGIN to locate own dependencies w/o need for LD_LIBRARY_PATH
+ +#ENABLE_RPATH=YES
+ +#RPATHLDFLAGS=${LD_RPATH}'$$ORIGIN'
+ +
+ +## Compiler switch to embed a library name
+ +LD_SONAME = -h $(MIDDLE_SO_TARGET)
+ +
+ +## Shared object suffix
+ +SO=		so
+ +## Non-shared intermediate object suffix
+ +STATIC_O = o
+ +
+ +## Compilation rules
+ +%.$(STATIC_O): $(srcdir)/%.c
+ +	$(COMPILE.c) $(STATICCPPFLAGS) $(STATICCFLAGS) -o $@ $<
+ +%.o: $(srcdir)/%.c
+ +	$(COMPILE.c) $(DYNAMICCPPFLAGS) $(DYNAMICCFLAGS) -o $@ $<
+ +
+ +%.$(STATIC_O): $(srcdir)/%.cpp
+ +	$(COMPILE.cc) $(STATICCPPFLAGS) $(STATICCXXFLAGS) -o $@ $<
+ +%.o: $(srcdir)/%.cpp
+ +	$(COMPILE.cc) $(DYNAMICCPPFLAGS) $(DYNAMICCXXFLAGS) -o $@ $<
+ +
+ +../data/%.o: ../data/%.c
+ +	$(COMPILE.c) $(DYNAMICCPPFLAGS) $(DYNAMICCFLAGS) -o $@ $<
+ +
+ +## Dependency rules
+ +%.d : $(srcdir)/%.c
+ +	@echo "generating dependency information for $<"
+ +
+ +
+ +%.d : $(srcdir)/%.cpp
+ +	@echo "generating dependency information for $<"
+ +
+ +
+ +## Versioned libraries rules
+ +
+ +%.$(SO).$(SO_TARGET_VERSION_MAJOR): %.$(SO).$(SO_TARGET_VERSION)
+ +	$(RM) $@ && ln -s $< $@
+ +%.$(SO): %.$(SO).$(SO_TARGET_VERSION_MAJOR)
+ +	$(RM) $@ && ln -s $*.$(SO).$(SO_TARGET_VERSION) $@
+ +
+ +# 
+ +BIR_LDFLAGS=  -Wl,-Bexport -Wl,-Bsymbolic
+ +BIR_CPPFLAGS= -DU_HAVE_BIND_INTERNAL_REFERENCES
+ +#BIR_DEPS=   $(NAME).map
+ +## End Solaris-specific setup
+ --- misc/build/icu/source/icudefs.mk.in.00	2005-10-26 22:50:40.000000000 -0700
+ +++ misc/build/icu/source/icudefs.mk.in	2005-10-26 22:53:45.181134002 -0700
+ @@ -87,7 +87,7 @@
+  CXX = @CXX@
+  AIX_SHLIB = @AIX_SHLIB@
+  AR = @AR@
+ -ARFLAGS := @ARFLAGS@ $(ARFLAGS)
+ +ARFLAGS := @ARFLAGS@
+  RANLIB = @RANLIB@
+  COMPILE_LINK_ENVVAR = @COMPILE_LINK_ENVVAR@
+  
*** ./libxmlsec/prj/build.lst.osr6	Tue May  3 07:27:38 2005
--- ./libxmlsec/prj/build.lst	Thu Oct 27 00:49:12 2005
***************
*** 1,3 ****
! ls  libxmlsec   : stlport soltools LIBXML2:libxml2 MOZ:moz SO:moz_prebuilt sal NULL
  ls	libxmlsec			    usr1	-	all	ls_mkout NULL
  ls	libxmlsec			    nmake	-	all	ls_xmlsec1 NULL
--- 1,3 ----
! ls  libxmlsec   : soltools LIBXML2:libxml2 MOZ:moz SO:moz_prebuilt sal NULL
  ls	libxmlsec			    usr1	-	all	ls_mkout NULL
  ls	libxmlsec			    nmake	-	all	ls_xmlsec1 NULL
*** ./nas/makefile.mk.osr6	Wed Oct  5 03:21:44 2005
--- ./nas/makefile.mk	Wed Oct 26 20:22:51 2005
***************
*** 71,81 ****
  
  BUILD_DIR=$(CONFIGURE_DIR)
  BUILD_ACTION=make World
! .IF "$(OS)"!="SOLARIS"
! BUILD_FLAGS=CC="$(CC)" CXX="$(CXX)" -j$(MAXPROCESS)
! .ELSE
! BUILD_FLAGS=CC="$(CC)" CXX="$(CXX)" 
! .ENDIF
  
  OUT2LIB= \
  	lib/audio/libaudio.a
--- 71,77 ----
  
  BUILD_DIR=$(CONFIGURE_DIR)
  BUILD_ACTION=make World
! BUILD_FLAGS=CC="$(CC)" CXX="$(CXX)" MAKE=/usr/gnu/bin/make
  
  OUT2LIB= \
  	lib/audio/libaudio.a
*** ./neon/prj/build.lst.osr6	Thu Feb 24 05:58:56 2005
--- ./neon/prj/build.lst	Wed Oct 26 20:22:51 2005
***************
*** 1,3 ****
! xh      neon  :  soltools external expat LIBXML2:libxml2 NULL
  xh      neon     usr1           -       all     xh_mkout NULL
  xh      neon     nmake          -       all     xh_neon NULL
--- 1,3 ----
! xh      neon  :  soltools external LIBXML2:libxml2 NULL
  xh      neon     usr1           -       all     xh_mkout NULL
  xh      neon     nmake          -       all     xh_neon NULL
*** ./odk/prj/build.lst.osr6	Mon Jan 31 09:21:38 2005
--- ./odk/prj/build.lst	Wed Oct 26 20:22:51 2005
***************
*** 1,4 ****
! od	odk	::	cppuhelper cpputools io jurt jut javaunohelper sandbox remotebridges stoc udkapi ridljar offapi unoil autodoc netbeans_integration NULL
  od	odk					usr1	-	all	od_mkout NULL
  od	odk\source\com\sun\star\lib\loader	nmake	-	all	od_loader NULL
  od	odk\source\unoapploader\win	nmake	-	n	od_unoapploaderwin NULL
--- 1,4 ----
! od	odk	::	cppuhelper cpputools io jurt jut javaunohelper sandbox remotebridges stoc udkapi ridljar offapi unoil netbeans_integration NULL
  od	odk					usr1	-	all	od_mkout NULL
  od	odk\source\com\sun\star\lib\loader	nmake	-	all	od_loader NULL
  od	odk\source\unoapploader\win	nmake	-	n	od_unoapploaderwin NULL
*** ./odk/setsdkenv_unix.csh.in.osr6	Fri Jun 17 02:37:41 2005
--- ./odk/setsdkenv_unix.csh.in	Wed Oct 26 21:14:01 2005
***************
*** 1,4 ****
! #! /usr/bin/csh
  
  # This script sets all enviroment variables, which are necessary for building 
  # the examples of the Office Development Kit.
--- 1,4 ----
! #! /usr/bin/tcsh
  
  # This script sets all enviroment variables, which are necessary for building 
  # the examples of the Office Development Kit.
*** ./pyuno/prj/build.lst.osr6	Fri Feb 11 07:43:55 2005
--- ./pyuno/prj/build.lst	Thu Oct 27 00:02:29 2005
***************
*** 1,4 ****
! pu	pyuno	:	stoc cpputools cppuhelper PYTHON:python NULL
  pu	pyuno				  usr1	-	all	br_mkout NULL
  pu	pyuno\zipcore	nmake	-	all	pu_zipcore NULL
  pu	pyuno\unotypes		nmake	-	all	pu_unotypes NULL
--- 1,4 ----
! pu	pyuno	:	stoc cpputools cppuhelper NULL
  pu	pyuno				  usr1	-	all	br_mkout NULL
  pu	pyuno\zipcore	nmake	-	all	pu_zipcore NULL
  pu	pyuno\unotypes		nmake	-	all	pu_unotypes NULL
*** ./sablot/prj/build.lst.osr6	Wed May 28 06:28:45 2003
--- ./sablot/prj/build.lst	Wed Oct 26 20:22:51 2005
***************
*** 1,3 ****
! xh	sablot	:	expat soltools sal NULL
  xh	sablot		usr1	-	all	xh_mkout NULL
  xh	sablot      nmake	-	all	xh_sablot NULL
--- 1,3 ----
! xh	sablot	:	soltools sal NULL
  xh	sablot		usr1	-	all	xh_mkout NULL
  xh	sablot      nmake	-	all	xh_sablot NULL
*** ./sal/inc/sal/types.h.osr6	Thu Sep  8 07:48:06 2005
--- ./sal/inc/sal/types.h	Wed Oct 26 20:22:52 2005
***************
*** 94,100 ****
  	/*  The following are macros that will add the 64 bit constant suffix. */
  	#define SAL_CONST_INT64(x)       x##i64
  	#define SAL_CONST_UINT64(x)      x##ui64
! #elif defined(__SUNPRO_CC) || defined(__SUNPRO_C) || defined (__GNUC__) || defined(__hpux) || defined (sgi)
  	#if SAL_TYPES_SIZEOFLONGLONG == 8
  		typedef signed long long    sal_Int64;
  		typedef unsigned long long  sal_uInt64;
--- 94,100 ----
  	/*  The following are macros that will add the 64 bit constant suffix. */
  	#define SAL_CONST_INT64(x)       x##i64
  	#define SAL_CONST_UINT64(x)      x##ui64
! #elif defined(__SUNPRO_CC) || defined(__SUNPRO_C) || defined (__GNUC__) || defined(__hpux) || defined (sgi) || defined (__USLC__)
  	#if SAL_TYPES_SIZEOFLONGLONG == 8
  		typedef signed long long    sal_Int64;
  		typedef unsigned long long  sal_uInt64;
*** ./sal/osl/unx/system.h.osr6	Thu Sep  8 08:02:09 2005
--- ./sal/osl/unx/system.h	Wed Oct 26 20:22:52 2005
***************
*** 211,220 ****
  #	include <shadow.h>
  #	include <netdb.h>
  #	include <sys/un.h>
! #	include <sys/netinet/tcp.h>
  #   include <sys/types.h>
  #   include <sys/byteorder.h>
  #   include <dlfcn.h>
  #   if BYTE_ORDER == LITTLE_ENDIAN
  #   	define _LITTLE_ENDIAN
  #   elif BYTE_ORDER == BIG_ENDIAN
--- 211,222 ----
  #	include <shadow.h>
  #	include <netdb.h>
  #	include <sys/un.h>
! #	include <netinet/tcp.h>
  #   include <sys/types.h>
  #   include <sys/byteorder.h>
  #   include <dlfcn.h>
+ #   define  IORESOURCE_TRANSFER_SYSV
+ #   define  IOCHANNEL_TRANSFER_BSD
  #   if BYTE_ORDER == LITTLE_ENDIAN
  #   	define _LITTLE_ENDIAN
  #   elif BYTE_ORDER == BIG_ENDIAN
***************
*** 229,236 ****
  extern int pthread_cancel(pthread_t);
  extern unsigned int nanosleep(unsigned int);
  #	define  SLEEP_TIMESPEC(timespec)  	(timespec .tv_sec > 0) ? sleep(timespec .tv_sec), nanosleep(timespec .tv_nsec) : nanosleep(timespec .tv_nsec)
- #	define  PATH_MAX 					_POSIX_PATH_MAX
- #	define	S_ISSOCK					S_ISFIFO 
  #	define	PTHREAD_SIGACTION 			pthread_sigaction
  #	define	STAT_PARENT					stat
  #endif
--- 231,236 ----
***************
*** 472,477 ****
--- 472,478 ----
  #	define MSG_MAXIOVLEN 	0
  #endif
  
+ #if 0
  /* BEGIN HACK */
  /* dummy define and declarations for IPX should be replaced by */
  /* original ipx headers when these are available for this platform */
***************
*** 486,491 ****
--- 487,493 ----
      char  sa_nodenum[6];
      unsigned short sa_socket;
  } SOCKADDR_IPX;
+ #endif /* 0 */
  
  #define NSPROTO_IPX      1000
  #define NSPROTO_SPX      1256
*** ./sal/osl/unx/process.c.osr6	Thu Sep  8 07:59:02 2005
--- ./sal/osl/unx/process.c	Wed Oct 26 20:22:52 2005
***************
*** 52,57 ****
--- 52,61 ----
  
  #include "system.h"
  
+ #ifdef __USLC__
+ #include <sys/uio.h>
+ #endif
+ 
  #ifndef _OSL_DIAGNOSE_H_
  #include <osl/diagnose.h>
  #endif
*** ./sal/osl/unx/system.c.osr6	Thu Sep  8 08:01:54 2005
--- ./sal/osl/unx/system.c	Wed Oct 26 20:22:52 2005
***************
*** 248,253 ****
--- 248,254 ----
  #include <shadow.h>
  #include <sys/types.h>
  
+ #if 0
  struct spwd *getspnam_r(const char *name, struct spwd* s, char* buffer, int size )
  {
    	struct spwd* res;
***************
*** 341,349 ****
--- 342,353 ----
  
    	return res;
  }
+ #endif /* 0 */
  #endif /* defined SCO */
  
+ #ifndef SCO
  extern int h_errno;
+ #endif /* SCO */
  
  struct hostent *gethostbyname_r(const char *name, struct hostent *result,
  								char *buffer, int buflen, int *h_errnop)
*** ./sal/osl/unx/util.c.osr6	Thu Sep  8 08:03:08 2005
--- ./sal/osl/unx/util.c	Wed Oct 26 20:22:52 2005
***************
*** 42,48 ****
  #include <sys/socket.h>
  #include <net/if.h>
  
! #ifdef SOLARIS
  #include <sys/sockio.h>
  #endif
  
--- 42,48 ----
  #include <sys/socket.h>
  #include <net/if.h>
  
! #if defined (SOLARIS) || defined (__USLC__)
  #include <sys/sockio.h>
  #endif
  
*** ./sal/osl/unx/file.cxx.osr6	Thu Sep  8 07:53:53 2005
--- ./sal/osl/unx/file.cxx	Thu Oct 27 12:37:26 2005
***************
*** 98,104 ****
  #include <string.h>
  #endif
  
! #if defined(SOLARIS)
  #include <sys/mnttab.h>
  #include <sys/statvfs.h>
  #define  HAVE_STATFS_H
--- 98,104 ----
  #include <string.h>
  #endif
  
! #if defined(SOLARIS) || defined(SCO)
  #include <sys/mnttab.h>
  #include <sys/statvfs.h>
  #define  HAVE_STATFS_H
***************
*** 264,270 ****
  static oslFileError   osl_unmountFloppy(oslVolumeDeviceHandle hFloppy);
  
  
! #if defined(SOLARIS)
  static sal_Bool       osl_isFloppyMounted(sal_Char* pszPath, sal_Char* pszMountPath);
  static sal_Bool       osl_getFloppyMountEntry(const sal_Char* pszPath, sal_Char* pBuffer);
  static sal_Bool       osl_checkFloppyPath(sal_Char* pszPath, sal_Char* pszFilePath, sal_Char* pszDevicePath);
--- 264,270 ----
  static oslFileError   osl_unmountFloppy(oslVolumeDeviceHandle hFloppy);
  
  
! #if defined(SOLARIS) || defined(SCO)
  static sal_Bool       osl_isFloppyMounted(sal_Char* pszPath, sal_Char* pszMountPath);
  static sal_Bool       osl_getFloppyMountEntry(const sal_Char* pszPath, sal_Char* pBuffer);
  static sal_Bool       osl_checkFloppyPath(sal_Char* pszPath, sal_Char* pszFilePath, sal_Char* pszDevicePath);
***************
*** 1334,1340 ****
  #	define __OSL_STATFS_IS_CASE_PRESERVING_FS(a) ((__OSL_MSDOS_SUPER_MAGIC != (a).f_type))
  #endif /* LINUX */
  
! #if defined(SOLARIS) || defined(IRIX)
  #   define __OSL_STATFS_STRUCT          		 struct statvfs
  #   define __OSL_STATFS(dir, sfs)	    		 statvfs((dir), (sfs))
  #   define __OSL_STATFS_BLKSIZ(a)       		 ((sal_uInt64)((a).f_frsize))
--- 1334,1340 ----
  #	define __OSL_STATFS_IS_CASE_PRESERVING_FS(a) ((__OSL_MSDOS_SUPER_MAGIC != (a).f_type))
  #endif /* LINUX */
  
! #if defined(SOLARIS) || defined(IRIX) || defined(SCO)
  #   define __OSL_STATFS_STRUCT          		 struct statvfs
  #   define __OSL_STATFS(dir, sfs)	    		 statvfs((dir), (sfs))
  #   define __OSL_STATFS_BLKSIZ(a)       		 ((sal_uInt64)((a).f_frsize))
***************
*** 1346,1352 ****
     of the target platforms fix it!!!! */
  #	define __OSL_STATFS_IS_CASE_SENSITIVE_FS(a)	 (1)
  #	define __OSL_STATFS_IS_CASE_PRESERVING_FS(a) (1)
! #endif /* SOLARIS || IRIX*/
  
  #   define __OSL_STATFS_INIT(a) 	    (memset(&(a), 0, sizeof(__OSL_STATFS_STRUCT)))
  
--- 1346,1352 ----
     of the target platforms fix it!!!! */
  #	define __OSL_STATFS_IS_CASE_SENSITIVE_FS(a)	 (1)
  #	define __OSL_STATFS_IS_CASE_PRESERVING_FS(a) (1)
! #endif /* SOLARIS || IRIX || SCO */
  
  #   define __OSL_STATFS_INIT(a) 	    (memset(&(a), 0, sizeof(__OSL_STATFS_STRUCT)))
  
***************
*** 2340,2359 ****
  
  /******************************************************************************
   *
!  *                  SOLARIS FLOPPY FUNCTIONS
   *
   *****************************************************************************/
  
! #if defined(SOLARIS)
! /* compare a given devicename with the typical device names on a Solaris box */
  static sal_Bool
  osl_isAFloppyDevice (const char* pDeviceName)
  {
      const char* pFloppyDevice [] = { 
          "/dev/fd",           "/dev/rfd", 
          "/dev/diskette",     "/dev/rdiskette", 
          "/vol/dev/diskette", "/vol/dev/rdiskette" 
      };
  
      int i;
      for (i = 0; i < (sizeof(pFloppyDevice)/sizeof(pFloppyDevice[0])); i++)
--- 2340,2368 ----
  
  /******************************************************************************
   *
!  *                  SOLARIS/SCO FLOPPY FUNCTIONS
   *
   *****************************************************************************/
  
! #if defined(SOLARIS) || defined(SCO)
! /* compare a given devicename with the typical device names on a SVR4 box */
  static sal_Bool
  osl_isAFloppyDevice (const char* pDeviceName)
  {
+ #if defined(SOLARIS)
      const char* pFloppyDevice [] = { 
          "/dev/fd",           "/dev/rfd", 
          "/dev/diskette",     "/dev/rdiskette", 
          "/vol/dev/diskette", "/vol/dev/rdiskette" 
      };
+ #endif
+ #if defined(SCO)
+     const char* pFloppyDevice [] = { 
+         "/dev/fd0",           "/dev/rfd0", 
+         "/dev/fd1",           "/dev/rfd1", 
+         "/dev/fd/0",          "/dev/fd/1" 
+     };
+ #endif
  
      int i;
      for (i = 0; i < (sizeof(pFloppyDevice)/sizeof(pFloppyDevice[0])); i++)
***************
*** 2555,2561 ****
      return osl_File_E_BUSY;
  }
  
! #endif /* SOLARIS */
  
  /******************************************************************************
   *
--- 2564,2570 ----
      return osl_File_E_BUSY;
  }
  
! #endif /* SOLARIS || SCO */
  
  /******************************************************************************
   *
*** ./sal/osl/unx/process_impl.cxx.osr6	Thu Sep  8 07:59:24 2005
--- ./sal/osl/unx/process_impl.cxx	Thu Oct 27 12:46:44 2005
***************
*** 141,146 ****
--- 141,151 ----
  
  #elif !defined(NO_DL_FUNCTIONS)
  #include <dlfcn.h>
+ #ifndef RTLD_DEFAULT
+ #if defined(SCO)
+ #define RTLD_DEFAULT RTLD_NEXT
+ #endif
+ #endif
  
  oslProcessError SAL_CALL osl_bootstrap_getExecutableFile_Impl (
  	rtl_uString ** ppFileURL
*** ./sal/prj/build.lst.osr6	Fri Nov 26 06:41:53 2004
--- ./sal/prj/build.lst	Thu Oct 27 00:49:31 2005
***************
*** 1,4 ****
! sa	sal	:	xml2cmp stlport NULL 
  sa	sal										usr1	-	all	sa_mkout NULL
  sa	sal\typesconfig						nmake	-	u	sa_tc NULL
  sa	sal\cpprt								nmake	-	u	sa_cpprt sa_util NULL
--- 1,4 ----
! sa	sal	:	NULL 
  sa	sal										usr1	-	all	sa_mkout NULL
  sa	sal\typesconfig						nmake	-	u	sa_tc NULL
  sa	sal\cpprt								nmake	-	u	sa_cpprt sa_util NULL
*** ./sal/rtl/source/bootstrap.cxx.osr6	Thu Sep  8 09:00:14 2005
--- ./sal/rtl/source/bootstrap.cxx	Wed Oct 26 20:22:52 2005
***************
*** 316,321 ****
--- 316,339 ----
      sal_Bool getValue( rtl_uString * pName, rtl_uString ** ppValue, rtl_uString * pDefault ) const;
  };
  
+ // specialization of user's allocator on void
+ // this mimics the generic allocator specialization
+ // add this after the MyAllocator template declaration
+ // From Judy Ward's post at
+ // http://softwareforums.intel.com/ids/board/message?board.id=16&message.id=749
+ template <>
+ struct MyAllocator
+ {
+ public:
+ typedef void* pointer;
+ typedef const void* const_pointer;
+ // reference-to-void members are impossible
+ typedef void value_type;
+ template
+ struct rebind { typedef MyAllocator other; };
+ };
+ 
+ 
  //----------------------------------------------------------------------------
  
  Bootstrap_Impl::Bootstrap_Impl( OUString const & rIniName )
*** ./sal/rtl/source/macro.hxx.osr6	Thu Sep  8 09:03:00 2005
--- ./sal/rtl/source/macro.hxx	Thu Oct 27 13:16:36 2005
***************
*** 41,46 ****
--- 41,48 ----
  
  #if defined WIN32
  #define THIS_OS "Windows"
+ #elif defined SCO
+ #define THIS_OS "SCO UNIX"
  #elif defined SOLARIS
  #define THIS_OS "Solaris"
  #elif defined LINUX
*** ./sax/prj/build.lst.osr6	Mon Aug 26 09:16:15 2002
--- ./sax/prj/build.lst	Wed Oct 26 20:22:52 2005
***************
*** 1,4 ****
! ax	sax	:	offapi cppuhelper expat NULL
  ax	sax										usr1	-	all	ax_mkout NULL
  ax	sax\unotypes							nmake	-	all	ax_unotypes NULL
  ax	sax\source\expatwrap					nmake	-	all	ax_expatwrap ax_unotypes NULL
--- 1,4 ----
! ax	sax	:	offapi cppuhelper NULL
  ax	sax										usr1	-	all	ax_mkout NULL
  ax	sax\unotypes							nmake	-	all	ax_unotypes NULL
  ax	sax\source\expatwrap					nmake	-	all	ax_expatwrap ax_unotypes NULL
*** ./scp2/prj/build.lst.osr6	Fri Aug  5 10:26:02 2005
--- ./scp2/prj/build.lst	Thu Oct 27 00:03:07 2005
***************
*** 1,4 ****
! cp    scp2    :    setup_native transex3 PYTHON:python icu NULL
  cp    scp2                        usr1     -    all    cp_mkout NULL
  cp    scp2\macros                 nmake    -    all    cp_langmacros NULL
  cp    scp2\source\activex         nmake    -    all    cp_activex cp_langmacros NULL
--- 1,4 ----
! cp    scp2    :    setup_native transex3 NULL
  cp    scp2                        usr1     -    all    cp_mkout NULL
  cp    scp2\macros                 nmake    -    all    cp_langmacros NULL
  cp    scp2\source\activex         nmake    -    all    cp_activex cp_langmacros NULL
*** ./shell/prj/build.lst.osr6	Thu Dec 16 03:17:42 2004
--- ./shell/prj/build.lst	Wed Oct 26 20:22:52 2005
***************
*** 1,4 ****
! sh    shell	: offuh rdbmaker tools sal expat transex3 NULL
  sh    shell\source\win32                           nmake   -   w   sh_win32 NULL
  sh    shell\source\win32\simplemail                nmake   -   w   sh_win32_simplemail NULL
  sh    shell\source\unix\exec                       nmake   -   u   sh_unix NULL
--- 1,4 ----
! sh    shell	: offuh rdbmaker tools sal transex3 NULL
  sh    shell\source\win32                           nmake   -   w   sh_win32 NULL
  sh    shell\source\win32\simplemail                nmake   -   w   sh_win32_simplemail NULL
  sh    shell\source\unix\exec                       nmake   -   u   sh_unix NULL
*** ./solenv/bin/config.guess.osr6	Mon Mar  7 09:27:16 2005
--- ./solenv/bin/config.guess	Wed Oct 26 20:22:52 2005
***************
*** 1,9 ****
  #! /bin/sh
  # Attempt to guess a canonical system name.
  #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
! #   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
  
! timestamp='2004-11-12'
  
  # This file is free software; you can redistribute it and/or modify it
  # under the terms of the GNU General Public License as published by
--- 1,9 ----
  #! /bin/sh
  # Attempt to guess a canonical system name.
  #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
! #   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
  
! timestamp='2005-09-19'
  
  # This file is free software; you can redistribute it and/or modify it
  # under the terms of the GNU General Public License as published by
***************
*** 17,29 ****
  #
  # You should have received a copy of the GNU General Public License
  # along with this program; if not, write to the Free Software
! # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  #
  # As a special exception to the GNU General Public License, if you
  # distribute this file as part of a program that contains a
  # configuration script generated by Autoconf, you may include it under
  # the same distribution terms that you use for the rest of that program.
  
  # Originally written by Per Bothner <per@bothner.com>.
  # Please send patches to <config-patches@gnu.org>.  Submit a context
  # diff and a properly formatted ChangeLog entry.
--- 17,31 ----
  #
  # You should have received a copy of the GNU General Public License
  # along with this program; if not, write to the Free Software
! # Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
! # 02110-1301, USA.
  #
  # As a special exception to the GNU General Public License, if you
  # distribute this file as part of a program that contains a
  # configuration script generated by Autoconf, you may include it under
  # the same distribution terms that you use for the rest of that program.
  
+ 
  # Originally written by Per Bothner <per@bothner.com>.
  # Please send patches to <config-patches@gnu.org>.  Submit a context
  # diff and a properly formatted ChangeLog entry.
***************
*** 53,59 ****
  GNU config.guess ($timestamp)
  
  Originally written by Per Bothner.
! Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
  Free Software Foundation, Inc.
  
  This is free software; see the source for copying conditions.  There is NO
--- 55,61 ----
  GNU config.guess ($timestamp)
  
  Originally written by Per Bothner.
! Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
  Free Software Foundation, Inc.
  
  This is free software; see the source for copying conditions.  There is NO
***************
*** 66,76 ****
  while test $# -gt 0 ; do
    case $1 in
      --time-stamp | --time* | -t )
!        echo "$timestamp" ; exit 0 ;;
      --version | -v )
!        echo "$version" ; exit 0 ;;
      --help | --h* | -h )
!        echo "$usage"; exit 0 ;;
      -- )     # Stop option processing
         shift; break ;;
      - )	# Use stdin as input.
--- 68,78 ----
  while test $# -gt 0 ; do
    case $1 in
      --time-stamp | --time* | -t )
!        echo "$timestamp" ; exit ;;
      --version | -v )
!        echo "$version" ; exit ;;
      --help | --h* | -h )
!        echo "$usage"; exit ;;
      -- )     # Stop option processing
         shift; break ;;
      - )	# Use stdin as input.
***************
*** 123,129 ****
  	;;
   ,,*)   CC_FOR_BUILD=$CC ;;
   ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
! esac ;'
  
  # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
  # (ghazi@noc.rutgers.edu 1994-08-24)
--- 125,131 ----
  	;;
   ,,*)   CC_FOR_BUILD=$CC ;;
   ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
! esac ; set_cc_for_build= ;'
  
  # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
  # (ghazi@noc.rutgers.edu 1994-08-24)
***************
*** 196,250 ****
  	# contains redundant information, the shorter form:
  	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
  	echo "${machine}-${os}${release}"
! 	exit 0 ;;
!     amd64:OpenBSD:*:*)
! 	echo x86_64-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     amiga:OpenBSD:*:*)
! 	echo m68k-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     cats:OpenBSD:*:*)
! 	echo arm-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     hp300:OpenBSD:*:*)
! 	echo m68k-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     luna88k:OpenBSD:*:*)
!     	echo m88k-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     mac68k:OpenBSD:*:*)
! 	echo m68k-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     macppc:OpenBSD:*:*)
! 	echo powerpc-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     mvme68k:OpenBSD:*:*)
! 	echo m68k-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     mvme88k:OpenBSD:*:*)
! 	echo m88k-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     mvmeppc:OpenBSD:*:*)
! 	echo powerpc-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     sgi:OpenBSD:*:*)
! 	echo mips64-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     sun3:OpenBSD:*:*)
! 	echo m68k-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
      *:OpenBSD:*:*)
! 	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
      *:ekkoBSD:*:*)
  	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
! 	exit 0 ;;
      macppc:MirBSD:*:*)
  	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
! 	exit 0 ;;
      *:MirBSD:*:*)
  	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
! 	exit 0 ;;
      alpha:OSF1:*:*)
  	case $UNAME_RELEASE in
  	*4.0)
--- 198,217 ----
  	# contains redundant information, the shorter form:
  	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
  	echo "${machine}-${os}${release}"
! 	exit ;;
      *:OpenBSD:*:*)
! 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
! 	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
! 	exit ;;
      *:ekkoBSD:*:*)
  	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
! 	exit ;;
      macppc:MirBSD:*:*)
  	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
! 	exit ;;
      *:MirBSD:*:*)
  	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
! 	exit ;;
      alpha:OSF1:*:*)
  	case $UNAME_RELEASE in
  	*4.0)
***************
*** 297,336 ****
  	# A Xn.n version is an unreleased experimental baselevel.
  	# 1.2 uses "1.2" for uname -r.
  	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
! 	exit 0 ;;
      Alpha\ *:Windows_NT*:*)
  	# How do we know it's Interix rather than the generic POSIX subsystem?
  	# Should we change UNAME_MACHINE based on the output of uname instead
  	# of the specific Alpha model?
  	echo alpha-pc-interix
! 	exit 0 ;;
      21064:Windows_NT:50:3)
  	echo alpha-dec-winnt3.5
! 	exit 0 ;;
      Amiga*:UNIX_System_V:4.0:*)
  	echo m68k-unknown-sysv4
! 	exit 0;;
      *:[Aa]miga[Oo][Ss]:*:*)
  	echo ${UNAME_MACHINE}-unknown-amigaos
! 	exit 0 ;;
      *:[Mm]orph[Oo][Ss]:*:*)
  	echo ${UNAME_MACHINE}-unknown-morphos
! 	exit 0 ;;
      *:OS/390:*:*)
  	echo i370-ibm-openedition
! 	exit 0 ;;
      *:z/VM:*:*)
  	echo s390-ibm-zvmoe
! 	exit 0 ;;
      *:OS400:*:*)
          echo powerpc-ibm-os400
! 	exit 0 ;;
      arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
  	echo arm-acorn-riscix${UNAME_RELEASE}
! 	exit 0;;
      SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
  	echo hppa1.1-hitachi-hiuxmpp
! 	exit 0;;
      Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
  	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
  	if test "`(/bin/universe) 2>/dev/null`" = att ; then
--- 264,306 ----
  	# A Xn.n version is an unreleased experimental baselevel.
  	# 1.2 uses "1.2" for uname -r.
  	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
! 	exit ;;
      Alpha\ *:Windows_NT*:*)
  	# How do we know it's Interix rather than the generic POSIX subsystem?
  	# Should we change UNAME_MACHINE based on the output of uname instead
  	# of the specific Alpha model?
  	echo alpha-pc-interix
! 	exit ;;
      21064:Windows_NT:50:3)
  	echo alpha-dec-winnt3.5
! 	exit ;;
      Amiga*:UNIX_System_V:4.0:*)
  	echo m68k-unknown-sysv4
! 	exit ;;
      *:[Aa]miga[Oo][Ss]:*:*)
  	echo ${UNAME_MACHINE}-unknown-amigaos
! 	exit ;;
      *:[Mm]orph[Oo][Ss]:*:*)
  	echo ${UNAME_MACHINE}-unknown-morphos
! 	exit ;;
      *:OS/390:*:*)
  	echo i370-ibm-openedition
! 	exit ;;
      *:z/VM:*:*)
  	echo s390-ibm-zvmoe
! 	exit ;;
      *:OS400:*:*)
          echo powerpc-ibm-os400
! 	exit ;;
      arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
  	echo arm-acorn-riscix${UNAME_RELEASE}
! 	exit ;;
!     arm:riscos:*:*|arm:RISCOS:*:*)
! 	echo arm-unknown-riscos
! 	exit ;;
      SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
  	echo hppa1.1-hitachi-hiuxmpp
! 	exit ;;
      Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
  	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
  	if test "`(/bin/universe) 2>/dev/null`" = att ; then
***************
*** 338,369 ****
  	else
  		echo pyramid-pyramid-bsd
  	fi
! 	exit 0 ;;
      NILE*:*:*:dcosx)
  	echo pyramid-pyramid-svr4
! 	exit 0 ;;
      DRS?6000:unix:4.0:6*)
  	echo sparc-icl-nx6
! 	exit 0 ;;
      DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
  	case `/usr/bin/uname -p` in
! 	    sparc) echo sparc-icl-nx7 && exit 0 ;;
  	esac ;;
      sun4H:SunOS:5.*:*)
  	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit 0 ;;
      sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
  	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit 0 ;;
      i86pc:SunOS:5.*:*)
  	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit 0 ;;
      sun4*:SunOS:6*:*)
  	# According to config.sub, this is the proper way to canonicalize
  	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
  	# it's likely to be more like Solaris than SunOS4.
  	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit 0 ;;
      sun4*:SunOS:*:*)
  	case "`/usr/bin/arch -k`" in
  	    Series*|S4*)
--- 308,339 ----
  	else
  		echo pyramid-pyramid-bsd
  	fi
! 	exit ;;
      NILE*:*:*:dcosx)
  	echo pyramid-pyramid-svr4
! 	exit ;;
      DRS?6000:unix:4.0:6*)
  	echo sparc-icl-nx6
! 	exit ;;
      DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
  	case `/usr/bin/uname -p` in
! 	    sparc) echo sparc-icl-nx7; exit ;;
  	esac ;;
      sun4H:SunOS:5.*:*)
  	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit ;;
      sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
  	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit ;;
      i86pc:SunOS:5.*:*)
  	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit ;;
      sun4*:SunOS:6*:*)
  	# According to config.sub, this is the proper way to canonicalize
  	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
  	# it's likely to be more like Solaris than SunOS4.
  	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit ;;
      sun4*:SunOS:*:*)
  	case "`/usr/bin/arch -k`" in
  	    Series*|S4*)
***************
*** 372,381 ****
  	esac
  	# Japanese Language versions have a version number like `4.1.3-JL'.
  	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
! 	exit 0 ;;
      sun3*:SunOS:*:*)
  	echo m68k-sun-sunos${UNAME_RELEASE}
! 	exit 0 ;;
      sun*:*:4.2BSD:*)
  	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
  	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
--- 342,351 ----
  	esac
  	# Japanese Language versions have a version number like `4.1.3-JL'.
  	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
! 	exit ;;
      sun3*:SunOS:*:*)
  	echo m68k-sun-sunos${UNAME_RELEASE}
! 	exit ;;
      sun*:*:4.2BSD:*)
  	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
  	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
***************
*** 387,396 ****
  		echo sparc-sun-sunos${UNAME_RELEASE}
  		;;
  	esac
! 	exit 0 ;;
      aushp:SunOS:*:*)
  	echo sparc-auspex-sunos${UNAME_RELEASE}
! 	exit 0 ;;
      # The situation for MiNT is a little confusing.  The machine name
      # can be virtually everything (everything which is not
      # "atarist" or "atariste" at least should have a processor
--- 357,366 ----
  		echo sparc-sun-sunos${UNAME_RELEASE}
  		;;
  	esac
! 	exit ;;
      aushp:SunOS:*:*)
  	echo sparc-auspex-sunos${UNAME_RELEASE}
! 	exit ;;
      # The situation for MiNT is a little confusing.  The machine name
      # can be virtually everything (everything which is not
      # "atarist" or "atariste" at least should have a processor
***************
*** 401,440 ****
      # be no problem.
      atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
          echo m68k-atari-mint${UNAME_RELEASE}
! 	exit 0 ;;
      atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
  	echo m68k-atari-mint${UNAME_RELEASE}
!         exit 0 ;;
      *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
          echo m68k-atari-mint${UNAME_RELEASE}
! 	exit 0 ;;
      milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
          echo m68k-milan-mint${UNAME_RELEASE}
!         exit 0 ;;
      hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
          echo m68k-hades-mint${UNAME_RELEASE}
!         exit 0 ;;
      *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
          echo m68k-unknown-mint${UNAME_RELEASE}
!         exit 0 ;;
      m68k:machten:*:*)
  	echo m68k-apple-machten${UNAME_RELEASE}
! 	exit 0 ;;
      powerpc:machten:*:*)
  	echo powerpc-apple-machten${UNAME_RELEASE}
! 	exit 0 ;;
      RISC*:Mach:*:*)
  	echo mips-dec-mach_bsd4.3
! 	exit 0 ;;
      RISC*:ULTRIX:*:*)
  	echo mips-dec-ultrix${UNAME_RELEASE}
! 	exit 0 ;;
      VAX*:ULTRIX*:*:*)
  	echo vax-dec-ultrix${UNAME_RELEASE}
! 	exit 0 ;;
      2020:CLIX:*:* | 2430:CLIX:*:*)
  	echo clipper-intergraph-clix${UNAME_RELEASE}
! 	exit 0 ;;
      mips:*:*:UMIPS | mips:*:*:RISCos)
  	eval $set_cc_for_build
  	sed 's/^	//' << EOF >$dummy.c
--- 371,410 ----
      # be no problem.
      atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
          echo m68k-atari-mint${UNAME_RELEASE}
! 	exit ;;
      atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
  	echo m68k-atari-mint${UNAME_RELEASE}
!         exit ;;
      *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
          echo m68k-atari-mint${UNAME_RELEASE}
! 	exit ;;
      milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
          echo m68k-milan-mint${UNAME_RELEASE}
!         exit ;;
      hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
          echo m68k-hades-mint${UNAME_RELEASE}
!         exit ;;
      *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
          echo m68k-unknown-mint${UNAME_RELEASE}
!         exit ;;
      m68k:machten:*:*)
  	echo m68k-apple-machten${UNAME_RELEASE}
! 	exit ;;
      powerpc:machten:*:*)
  	echo powerpc-apple-machten${UNAME_RELEASE}
! 	exit ;;
      RISC*:Mach:*:*)
  	echo mips-dec-mach_bsd4.3
! 	exit ;;
      RISC*:ULTRIX:*:*)
  	echo mips-dec-ultrix${UNAME_RELEASE}
! 	exit ;;
      VAX*:ULTRIX*:*:*)
  	echo vax-dec-ultrix${UNAME_RELEASE}
! 	exit ;;
      2020:CLIX:*:* | 2430:CLIX:*:*)
  	echo clipper-intergraph-clix${UNAME_RELEASE}
! 	exit ;;
      mips:*:*:UMIPS | mips:*:*:RISCos)
  	eval $set_cc_for_build
  	sed 's/^	//' << EOF >$dummy.c
***************
*** 458,489 ****
  	  exit (-1);
  	}
  EOF
! 	$CC_FOR_BUILD -o $dummy $dummy.c \
! 	  && $dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
! 	  && exit 0
  	echo mips-mips-riscos${UNAME_RELEASE}
! 	exit 0 ;;
      Motorola:PowerMAX_OS:*:*)
  	echo powerpc-motorola-powermax
! 	exit 0 ;;
      Motorola:*:4.3:PL8-*)
  	echo powerpc-harris-powermax
! 	exit 0 ;;
      Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
  	echo powerpc-harris-powermax
! 	exit 0 ;;
      Night_Hawk:Power_UNIX:*:*)
  	echo powerpc-harris-powerunix
! 	exit 0 ;;
      m88k:CX/UX:7*:*)
  	echo m88k-harris-cxux7
! 	exit 0 ;;
      m88k:*:4*:R4*)
  	echo m88k-motorola-sysv4
! 	exit 0 ;;
      m88k:*:3*:R3*)
  	echo m88k-motorola-sysv3
! 	exit 0 ;;
      AViiON:dgux:*:*)
          # DG/UX returns AViiON for all architectures
          UNAME_PROCESSOR=`/usr/bin/uname -p`
--- 428,460 ----
  	  exit (-1);
  	}
  EOF
! 	$CC_FOR_BUILD -o $dummy $dummy.c &&
! 	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
! 	  SYSTEM_NAME=`$dummy $dummyarg` &&
! 	    { echo "$SYSTEM_NAME"; exit; }
  	echo mips-mips-riscos${UNAME_RELEASE}
! 	exit ;;
      Motorola:PowerMAX_OS:*:*)
  	echo powerpc-motorola-powermax
! 	exit ;;
      Motorola:*:4.3:PL8-*)
  	echo powerpc-harris-powermax
! 	exit ;;
      Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
  	echo powerpc-harris-powermax
! 	exit ;;
      Night_Hawk:Power_UNIX:*:*)
  	echo powerpc-harris-powerunix
! 	exit ;;
      m88k:CX/UX:7*:*)
  	echo m88k-harris-cxux7
! 	exit ;;
      m88k:*:4*:R4*)
  	echo m88k-motorola-sysv4
! 	exit ;;
      m88k:*:3*:R3*)
  	echo m88k-motorola-sysv3
! 	exit ;;
      AViiON:dgux:*:*)
          # DG/UX returns AViiON for all architectures
          UNAME_PROCESSOR=`/usr/bin/uname -p`
***************
*** 499,527 ****
  	else
  	    echo i586-dg-dgux${UNAME_RELEASE}
  	fi
!  	exit 0 ;;
      M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
  	echo m88k-dolphin-sysv3
! 	exit 0 ;;
      M88*:*:R3*:*)
  	# Delta 88k system running SVR3
  	echo m88k-motorola-sysv3
! 	exit 0 ;;
      XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
  	echo m88k-tektronix-sysv3
! 	exit 0 ;;
      Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
  	echo m68k-tektronix-bsd
! 	exit 0 ;;
      *:IRIX*:*:*)
  	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
! 	exit 0 ;;
      ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
! 	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
! 	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
      i*86:AIX:*:*)
  	echo i386-ibm-aix
! 	exit 0 ;;
      ia64:AIX:*:*)
  	if [ -x /usr/bin/oslevel ] ; then
  		IBM_REV=`/usr/bin/oslevel`
--- 470,498 ----
  	else
  	    echo i586-dg-dgux${UNAME_RELEASE}
  	fi
!  	exit ;;
      M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
  	echo m88k-dolphin-sysv3
! 	exit ;;
      M88*:*:R3*:*)
  	# Delta 88k system running SVR3
  	echo m88k-motorola-sysv3
! 	exit ;;
      XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
  	echo m88k-tektronix-sysv3
! 	exit ;;
      Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
  	echo m68k-tektronix-bsd
! 	exit ;;
      *:IRIX*:*:*)
  	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
! 	exit ;;
      ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
! 	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
! 	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
      i*86:AIX:*:*)
  	echo i386-ibm-aix
! 	exit ;;
      ia64:AIX:*:*)
  	if [ -x /usr/bin/oslevel ] ; then
  		IBM_REV=`/usr/bin/oslevel`
***************
*** 529,535 ****
  		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
  	fi
  	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
! 	exit 0 ;;
      *:AIX:2:3)
  	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
  		eval $set_cc_for_build
--- 500,506 ----
  		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
  	fi
  	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
! 	exit ;;
      *:AIX:2:3)
  	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
  		eval $set_cc_for_build
***************
*** 544,557 ****
  			exit(0);
  			}
  EOF
! 		$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
! 		echo rs6000-ibm-aix3.2.5
  	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
  		echo rs6000-ibm-aix3.2.4
  	else
  		echo rs6000-ibm-aix3.2
  	fi
! 	exit 0 ;;
      *:AIX:*:[45])
  	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
  	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
--- 515,532 ----
  			exit(0);
  			}
  EOF
! 		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
! 		then
! 			echo "$SYSTEM_NAME"
! 		else
! 			echo rs6000-ibm-aix3.2.5
! 		fi
  	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
  		echo rs6000-ibm-aix3.2.4
  	else
  		echo rs6000-ibm-aix3.2
  	fi
! 	exit ;;
      *:AIX:*:[45])
  	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
  	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
***************
*** 565,592 ****
  		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
  	fi
  	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
! 	exit 0 ;;
      *:AIX:*:*)
  	echo rs6000-ibm-aix
! 	exit 0 ;;
      ibmrt:4.4BSD:*|romp-ibm:BSD:*)
  	echo romp-ibm-bsd4.4
! 	exit 0 ;;
      ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
  	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
! 	exit 0 ;;                           # report: romp-ibm BSD 4.3
      *:BOSX:*:*)
  	echo rs6000-bull-bosx
! 	exit 0 ;;
      DPX/2?00:B.O.S.:*:*)
  	echo m68k-bull-sysv3
! 	exit 0 ;;
      9000/[34]??:4.3bsd:1.*:*)
  	echo m68k-hp-bsd
! 	exit 0 ;;
      hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
  	echo m68k-hp-bsd4.4
! 	exit 0 ;;
      9000/[34678]??:HP-UX:*:*)
  	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
  	case "${UNAME_MACHINE}" in
--- 540,567 ----
  		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
  	fi
  	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
! 	exit ;;
      *:AIX:*:*)
  	echo rs6000-ibm-aix
! 	exit ;;
      ibmrt:4.4BSD:*|romp-ibm:BSD:*)
  	echo romp-ibm-bsd4.4
! 	exit ;;
      ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
  	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
! 	exit ;;                             # report: romp-ibm BSD 4.3
      *:BOSX:*:*)
  	echo rs6000-bull-bosx
! 	exit ;;
      DPX/2?00:B.O.S.:*:*)
  	echo m68k-bull-sysv3
! 	exit ;;
      9000/[34]??:4.3bsd:1.*:*)
  	echo m68k-hp-bsd
! 	exit ;;
      hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
  	echo m68k-hp-bsd4.4
! 	exit ;;
      9000/[34678]??:HP-UX:*:*)
  	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
  	case "${UNAME_MACHINE}" in
***************
*** 648,656 ****
  	esac
  	if [ ${HP_ARCH} = "hppa2.0w" ]
  	then
! 	    # avoid double evaluation of $set_cc_for_build
! 	    test -n "$CC_FOR_BUILD" || eval $set_cc_for_build
! 	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E -) | grep __LP64__ >/dev/null
  	    then
  		HP_ARCH="hppa2.0w"
  	    else
--- 623,641 ----
  	esac
  	if [ ${HP_ARCH} = "hppa2.0w" ]
  	then
! 	    eval $set_cc_for_build
! 
! 	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
! 	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
! 	    # generating 64-bit code.  GNU and HP use different nomenclature:
! 	    #
! 	    # $ CC_FOR_BUILD=cc ./config.guess
! 	    # => hppa2.0w-hp-hpux11.23
! 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
! 	    # => hppa64-hp-hpux11.23
! 
! 	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
! 		grep __LP64__ >/dev/null
  	    then
  		HP_ARCH="hppa2.0w"
  	    else
***************
*** 658,668 ****
  	    fi
  	fi
  	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
! 	exit 0 ;;
      ia64:HP-UX:*:*)
  	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
  	echo ia64-hp-hpux${HPUX_REV}
! 	exit 0 ;;
      3050*:HI-UX:*:*)
  	eval $set_cc_for_build
  	sed 's/^	//' << EOF >$dummy.c
--- 643,653 ----
  	    fi
  	fi
  	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
! 	exit ;;
      ia64:HP-UX:*:*)
  	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
  	echo ia64-hp-hpux${HPUX_REV}
! 	exit ;;
      3050*:HI-UX:*:*)
  	eval $set_cc_for_build
  	sed 's/^	//' << EOF >$dummy.c
***************
*** 690,847 ****
  	  exit (0);
  	}
  EOF
! 	$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
  	echo unknown-hitachi-hiuxwe2
! 	exit 0 ;;
      9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
  	echo hppa1.1-hp-bsd
! 	exit 0 ;;
      9000/8??:4.3bsd:*:*)
  	echo hppa1.0-hp-bsd
! 	exit 0 ;;
      *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
  	echo hppa1.0-hp-mpeix
! 	exit 0 ;;
      hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
  	echo hppa1.1-hp-osf
! 	exit 0 ;;
      hp8??:OSF1:*:*)
  	echo hppa1.0-hp-osf
! 	exit 0 ;;
      i*86:OSF1:*:*)
  	if [ -x /usr/sbin/sysversion ] ; then
  	    echo ${UNAME_MACHINE}-unknown-osf1mk
  	else
  	    echo ${UNAME_MACHINE}-unknown-osf1
  	fi
! 	exit 0 ;;
      parisc*:Lites*:*:*)
  	echo hppa1.1-hp-lites
! 	exit 0 ;;
      C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
  	echo c1-convex-bsd
!         exit 0 ;;
      C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
  	if getsysinfo -f scalar_acc
  	then echo c32-convex-bsd
  	else echo c2-convex-bsd
  	fi
!         exit 0 ;;
      C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
  	echo c34-convex-bsd
!         exit 0 ;;
      C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
  	echo c38-convex-bsd
!         exit 0 ;;
      C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
  	echo c4-convex-bsd
!         exit 0 ;;
      CRAY*Y-MP:*:*:*)
  	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit 0 ;;
      CRAY*[A-Z]90:*:*:*)
  	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
  	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
  	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
  	      -e 's/\.[^.]*$/.X/'
! 	exit 0 ;;
      CRAY*TS:*:*:*)
  	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit 0 ;;
      CRAY*T3E:*:*:*)
  	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit 0 ;;
      CRAY*SV1:*:*:*)
  	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit 0 ;;
      *:UNICOS/mp:*:*)
  	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit 0 ;;
      F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
  	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
          FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
          FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
          echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
!         exit 0 ;;
      5000:UNIX_System_V:4.*:*)
          FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
          FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
          echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
! 	exit 0 ;;
      i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
  	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
! 	exit 0 ;;
      sparc*:BSD/OS:*:*)
  	echo sparc-unknown-bsdi${UNAME_RELEASE}
! 	exit 0 ;;
      *:BSD/OS:*:*)
  	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
! 	exit 0 ;;
      *:FreeBSD:*:*)
  	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
! 	exit 0 ;;
      i*:CYGWIN*:*)
  	echo ${UNAME_MACHINE}-pc-cygwin
! 	exit 0 ;;
      i*:MINGW*:*)
  	echo ${UNAME_MACHINE}-pc-mingw32
! 	exit 0 ;;
      i*:PW*:*)
  	echo ${UNAME_MACHINE}-pc-pw32
! 	exit 0 ;;
      x86:Interix*:[34]*)
  	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
! 	exit 0 ;;
      [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
  	echo i${UNAME_MACHINE}-pc-mks
! 	exit 0 ;;
      i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
  	# How do we know it's Interix rather than the generic POSIX subsystem?
  	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
  	# UNAME_MACHINE based on the output of uname instead of i386?
  	echo i586-pc-interix
! 	exit 0 ;;
      i*:UWIN*:*)
  	echo ${UNAME_MACHINE}-pc-uwin
! 	exit 0 ;;
      p*:CYGWIN*:*)
  	echo powerpcle-unknown-cygwin
! 	exit 0 ;;
      prep*:SunOS:5.*:*)
  	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit 0 ;;
      *:GNU:*:*)
  	# the GNU system
  	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
! 	exit 0 ;;
      *:GNU/*:*:*)
  	# other systems with GNU libc and userland
  	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
! 	exit 0 ;;
      i*86:Minix:*:*)
  	echo ${UNAME_MACHINE}-pc-minix
! 	exit 0 ;;
      arm*:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit 0 ;;
      cris:Linux:*:*)
  	echo cris-axis-linux-gnu
! 	exit 0 ;;
      crisv32:Linux:*:*)
  	echo crisv32-axis-linux-gnu
! 	exit 0 ;;
      frv:Linux:*:*)
      	echo frv-unknown-linux-gnu
! 	exit 0 ;;
      ia64:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit 0 ;;
      m32r*:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit 0 ;;
      m68*:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit 0 ;;
      mips:Linux:*:*)
  	eval $set_cc_for_build
  	sed 's/^	//' << EOF >$dummy.c
--- 675,840 ----
  	  exit (0);
  	}
  EOF
! 	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
! 		{ echo "$SYSTEM_NAME"; exit; }
  	echo unknown-hitachi-hiuxwe2
! 	exit ;;
      9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
  	echo hppa1.1-hp-bsd
! 	exit ;;
      9000/8??:4.3bsd:*:*)
  	echo hppa1.0-hp-bsd
! 	exit ;;
      *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
  	echo hppa1.0-hp-mpeix
! 	exit ;;
      hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
  	echo hppa1.1-hp-osf
! 	exit ;;
      hp8??:OSF1:*:*)
  	echo hppa1.0-hp-osf
! 	exit ;;
      i*86:OSF1:*:*)
  	if [ -x /usr/sbin/sysversion ] ; then
  	    echo ${UNAME_MACHINE}-unknown-osf1mk
  	else
  	    echo ${UNAME_MACHINE}-unknown-osf1
  	fi
! 	exit ;;
      parisc*:Lites*:*:*)
  	echo hppa1.1-hp-lites
! 	exit ;;
      C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
  	echo c1-convex-bsd
!         exit ;;
      C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
  	if getsysinfo -f scalar_acc
  	then echo c32-convex-bsd
  	else echo c2-convex-bsd
  	fi
!         exit ;;
      C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
  	echo c34-convex-bsd
!         exit ;;
      C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
  	echo c38-convex-bsd
!         exit ;;
      C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
  	echo c4-convex-bsd
!         exit ;;
      CRAY*Y-MP:*:*:*)
  	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit ;;
      CRAY*[A-Z]90:*:*:*)
  	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
  	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
  	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
  	      -e 's/\.[^.]*$/.X/'
! 	exit ;;
      CRAY*TS:*:*:*)
  	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit ;;
      CRAY*T3E:*:*:*)
  	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit ;;
      CRAY*SV1:*:*:*)
  	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit ;;
      *:UNICOS/mp:*:*)
  	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
! 	exit ;;
      F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
  	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
          FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
          FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
          echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
!         exit ;;
      5000:UNIX_System_V:4.*:*)
          FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
          FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
          echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
! 	exit ;;
      i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
  	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
! 	exit ;;
      sparc*:BSD/OS:*:*)
  	echo sparc-unknown-bsdi${UNAME_RELEASE}
! 	exit ;;
      *:BSD/OS:*:*)
  	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
! 	exit ;;
      *:FreeBSD:*:*)
  	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
! 	exit ;;
      i*:CYGWIN*:*)
  	echo ${UNAME_MACHINE}-pc-cygwin
! 	exit ;;
      i*:MINGW*:*)
  	echo ${UNAME_MACHINE}-pc-mingw32
! 	exit ;;
!     i*:windows32*:*)
!     	# uname -m includes "-pc" on this system.
!     	echo ${UNAME_MACHINE}-mingw32
! 	exit ;;
      i*:PW*:*)
  	echo ${UNAME_MACHINE}-pc-pw32
! 	exit ;;
      x86:Interix*:[34]*)
  	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
! 	exit ;;
      [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
  	echo i${UNAME_MACHINE}-pc-mks
! 	exit ;;
      i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
  	# How do we know it's Interix rather than the generic POSIX subsystem?
  	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
  	# UNAME_MACHINE based on the output of uname instead of i386?
  	echo i586-pc-interix
! 	exit ;;
      i*:UWIN*:*)
  	echo ${UNAME_MACHINE}-pc-uwin
! 	exit ;;
!     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
! 	echo x86_64-unknown-cygwin
! 	exit ;;
      p*:CYGWIN*:*)
  	echo powerpcle-unknown-cygwin
! 	exit ;;
      prep*:SunOS:5.*:*)
  	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit ;;
      *:GNU:*:*)
  	# the GNU system
  	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
! 	exit ;;
      *:GNU/*:*:*)
  	# other systems with GNU libc and userland
  	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
! 	exit ;;
      i*86:Minix:*:*)
  	echo ${UNAME_MACHINE}-pc-minix
! 	exit ;;
      arm*:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit ;;
      cris:Linux:*:*)
  	echo cris-axis-linux-gnu
! 	exit ;;
      crisv32:Linux:*:*)
  	echo crisv32-axis-linux-gnu
! 	exit ;;
      frv:Linux:*:*)
      	echo frv-unknown-linux-gnu
! 	exit ;;
      ia64:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit ;;
      m32r*:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit ;;
      m68*:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit ;;
      mips:Linux:*:*)
  	eval $set_cc_for_build
  	sed 's/^	//' << EOF >$dummy.c
***************
*** 859,865 ****
  	#endif
  EOF
  	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
! 	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
  	;;
      mips64:Linux:*:*)
  	eval $set_cc_for_build
--- 852,858 ----
  	#endif
  EOF
  	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
! 	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
  	;;
      mips64:Linux:*:*)
  	eval $set_cc_for_build
***************
*** 878,891 ****
  	#endif
  EOF
  	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
! 	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
  	;;
      ppc:Linux:*:*)
  	echo powerpc-unknown-linux-gnu
! 	exit 0 ;;
      ppc64:Linux:*:*)
  	echo powerpc64-unknown-linux-gnu
! 	exit 0 ;;
      alpha:Linux:*:*)
  	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
  	  EV5)   UNAME_MACHINE=alphaev5 ;;
--- 871,887 ----
  	#endif
  EOF
  	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
! 	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
  	;;
+     or32:Linux:*:*)
+ 	echo or32-unknown-linux-gnu
+ 	exit ;;
      ppc:Linux:*:*)
  	echo powerpc-unknown-linux-gnu
! 	exit ;;
      ppc64:Linux:*:*)
  	echo powerpc64-unknown-linux-gnu
! 	exit ;;
      alpha:Linux:*:*)
  	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
  	  EV5)   UNAME_MACHINE=alphaev5 ;;
***************
*** 899,905 ****
  	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
  	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
  	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
! 	exit 0 ;;
      parisc:Linux:*:* | hppa:Linux:*:*)
  	# Look for CPU level
  	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
--- 895,901 ----
  	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
  	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
  	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
! 	exit ;;
      parisc:Linux:*:* | hppa:Linux:*:*)
  	# Look for CPU level
  	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
***************
*** 907,931 ****
  	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
  	  *)    echo hppa-unknown-linux-gnu ;;
  	esac
! 	exit 0 ;;
      parisc64:Linux:*:* | hppa64:Linux:*:*)
  	echo hppa64-unknown-linux-gnu
! 	exit 0 ;;
      s390:Linux:*:* | s390x:Linux:*:*)
  	echo ${UNAME_MACHINE}-ibm-linux
! 	exit 0 ;;
      sh64*:Linux:*:*)
      	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit 0 ;;
      sh*:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit 0 ;;
      sparc:Linux:*:* | sparc64:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit 0 ;;
      x86_64:Linux:*:*)
  	echo x86_64-unknown-linux-gnu
! 	exit 0 ;;
      i*86:Linux:*:*)
  	# The BFD linker knows what the default object file format is, so
  	# first see if it will tell us. cd to the root directory to prevent
--- 903,927 ----
  	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
  	  *)    echo hppa-unknown-linux-gnu ;;
  	esac
! 	exit ;;
      parisc64:Linux:*:* | hppa64:Linux:*:*)
  	echo hppa64-unknown-linux-gnu
! 	exit ;;
      s390:Linux:*:* | s390x:Linux:*:*)
  	echo ${UNAME_MACHINE}-ibm-linux
! 	exit ;;
      sh64*:Linux:*:*)
      	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit ;;
      sh*:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit ;;
      sparc:Linux:*:* | sparc64:Linux:*:*)
  	echo ${UNAME_MACHINE}-unknown-linux-gnu
! 	exit ;;
      x86_64:Linux:*:*)
  	echo x86_64-unknown-linux-gnu
! 	exit ;;
      i*86:Linux:*:*)
  	# The BFD linker knows what the default object file format is, so
  	# first see if it will tell us. cd to the root directory to prevent
***************
*** 943,957 ****
  		;;
  	  a.out-i386-linux)
  		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
! 		exit 0 ;;
  	  coff-i386)
  		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
! 		exit 0 ;;
  	  "")
  		# Either a pre-BFD a.out linker (linux-gnuoldld) or
  		# one that does not give us useful --help.
  		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
! 		exit 0 ;;
  	esac
  	# Determine whether the default compiler is a.out or elf
  	eval $set_cc_for_build
--- 939,953 ----
  		;;
  	  a.out-i386-linux)
  		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
! 		exit ;;
  	  coff-i386)
  		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
! 		exit ;;
  	  "")
  		# Either a pre-BFD a.out linker (linux-gnuoldld) or
  		# one that does not give us useful --help.
  		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
! 		exit ;;
  	esac
  	# Determine whether the default compiler is a.out or elf
  	eval $set_cc_for_build
***************
*** 979,993 ****
  	#endif
  EOF
  	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
! 	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
! 	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
  	;;
      i*86:DYNIX/ptx:4*:*)
  	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
  	# earlier versions are messed up and put the nodename in both
  	# sysname and nodename.
  	echo i386-sequent-sysv4
! 	exit 0 ;;
      i*86:UNIX_SV:4.2MP:2.*)
          # Unixware is an offshoot of SVR4, but it has its own version
          # number series starting with 2...
--- 975,992 ----
  	#endif
  EOF
  	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
! 	test x"${LIBC}" != x && {
! 		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
! 		exit
! 	}
! 	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
  	;;
      i*86:DYNIX/ptx:4*:*)
  	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
  	# earlier versions are messed up and put the nodename in both
  	# sysname and nodename.
  	echo i386-sequent-sysv4
! 	exit ;;
      i*86:UNIX_SV:4.2MP:2.*)
          # Unixware is an offshoot of SVR4, but it has its own version
          # number series starting with 2...
***************
*** 995,1021 ****
  	# I just have to hope.  -- rms.
          # Use sysv4.2uw... so that sysv4* matches it.
  	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
! 	exit 0 ;;
      i*86:OS/2:*:*)
  	# If we were able to find `uname', then EMX Unix compatibility
  	# is probably installed.
  	echo ${UNAME_MACHINE}-pc-os2-emx
! 	exit 0 ;;
      i*86:XTS-300:*:STOP)
  	echo ${UNAME_MACHINE}-unknown-stop
! 	exit 0 ;;
      i*86:atheos:*:*)
  	echo ${UNAME_MACHINE}-unknown-atheos
! 	exit 0 ;;
! 	i*86:syllable:*:*)
  	echo ${UNAME_MACHINE}-pc-syllable
! 	exit 0 ;;
      i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
  	echo i386-unknown-lynxos${UNAME_RELEASE}
! 	exit 0 ;;
      i*86:*DOS:*:*)
  	echo ${UNAME_MACHINE}-pc-msdosdjgpp
! 	exit 0 ;;
      i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
  	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
  	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
--- 994,1020 ----
  	# I just have to hope.  -- rms.
          # Use sysv4.2uw... so that sysv4* matches it.
  	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
! 	exit ;;
      i*86:OS/2:*:*)
  	# If we were able to find `uname', then EMX Unix compatibility
  	# is probably installed.
  	echo ${UNAME_MACHINE}-pc-os2-emx
! 	exit ;;
      i*86:XTS-300:*:STOP)
  	echo ${UNAME_MACHINE}-unknown-stop
! 	exit ;;
      i*86:atheos:*:*)
  	echo ${UNAME_MACHINE}-unknown-atheos
! 	exit ;;
!     i*86:syllable:*:*)
  	echo ${UNAME_MACHINE}-pc-syllable
! 	exit ;;
      i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
  	echo i386-unknown-lynxos${UNAME_RELEASE}
! 	exit ;;
      i*86:*DOS:*:*)
  	echo ${UNAME_MACHINE}-pc-msdosdjgpp
! 	exit ;;
      i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
  	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
  	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
***************
*** 1023,1037 ****
  	else
  		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
  	fi
! 	exit 0 ;;
!     i*86:*:5:[78]*)
  	case `/bin/uname -X | grep "^Machine"` in
  	    *486*)	     UNAME_MACHINE=i486 ;;
  	    *Pentium)	     UNAME_MACHINE=i586 ;;
  	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
  	esac
  	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
! 	exit 0 ;;
      i*86:*:3.2:*)
  	if test -f /usr/options/cb.name; then
  		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
--- 1022,1037 ----
  	else
  		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
  	fi
! 	exit ;;
!     i*86:*:5:[678]*)
!     	# UnixWare 7.x, OpenUNIX and OpenServer 6.
  	case `/bin/uname -X | grep "^Machine"` in
  	    *486*)	     UNAME_MACHINE=i486 ;;
  	    *Pentium)	     UNAME_MACHINE=i586 ;;
  	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
  	esac
  	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
! 	exit ;;
      i*86:*:3.2:*)
  	if test -f /usr/options/cb.name; then
  		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
***************
*** 1049,1121 ****
  	else
  		echo ${UNAME_MACHINE}-pc-sysv32
  	fi
! 	exit 0 ;;
      pc:*:*:*)
  	# Left here for compatibility:
          # uname -m prints for DJGPP always 'pc', but it prints nothing about
          # the processor, so we play safe by assuming i386.
  	echo i386-pc-msdosdjgpp
!         exit 0 ;;
      Intel:Mach:3*:*)
  	echo i386-pc-mach3
! 	exit 0 ;;
      paragon:*:*:*)
  	echo i860-intel-osf1
! 	exit 0 ;;
      i860:*:4.*:*) # i860-SVR4
  	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
  	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
  	else # Add other i860-SVR4 vendors below as they are discovered.
  	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
  	fi
! 	exit 0 ;;
      mini*:CTIX:SYS*5:*)
  	# "miniframe"
  	echo m68010-convergent-sysv
! 	exit 0 ;;
      mc68k:UNIX:SYSTEM5:3.51m)
  	echo m68k-convergent-sysv
! 	exit 0 ;;
      M680?0:D-NIX:5.3:*)
  	echo m68k-diab-dnix
! 	exit 0 ;;
      M68*:*:R3V[5678]*:*)
! 	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
      3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
  	OS_REL=''
  	test -r /etc/.relid \
  	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
  	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
! 	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
  	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
! 	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
      3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
          /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
!           && echo i486-ncr-sysv4 && exit 0 ;;
      m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
  	echo m68k-unknown-lynxos${UNAME_RELEASE}
! 	exit 0 ;;
      mc68030:UNIX_System_V:4.*:*)
  	echo m68k-atari-sysv4
! 	exit 0 ;;
      TSUNAMI:LynxOS:2.*:*)
  	echo sparc-unknown-lynxos${UNAME_RELEASE}
! 	exit 0 ;;
      rs6000:LynxOS:2.*:*)
  	echo rs6000-unknown-lynxos${UNAME_RELEASE}
! 	exit 0 ;;
      PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
  	echo powerpc-unknown-lynxos${UNAME_RELEASE}
! 	exit 0 ;;
      SM[BE]S:UNIX_SV:*:*)
  	echo mips-dde-sysv${UNAME_RELEASE}
! 	exit 0 ;;
      RM*:ReliantUNIX-*:*:*)
  	echo mips-sni-sysv4
! 	exit 0 ;;
      RM*:SINIX-*:*:*)
  	echo mips-sni-sysv4
! 	exit 0 ;;
      *:SINIX-*:*:*)
  	if uname -p 2>/dev/null >/dev/null ; then
  		UNAME_MACHINE=`(uname -p) 2>/dev/null`
--- 1049,1121 ----
  	else
  		echo ${UNAME_MACHINE}-pc-sysv32
  	fi
! 	exit ;;
      pc:*:*:*)
  	# Left here for compatibility:
          # uname -m prints for DJGPP always 'pc', but it prints nothing about
          # the processor, so we play safe by assuming i386.
  	echo i386-pc-msdosdjgpp
!         exit ;;
      Intel:Mach:3*:*)
  	echo i386-pc-mach3
! 	exit ;;
      paragon:*:*:*)
  	echo i860-intel-osf1
! 	exit ;;
      i860:*:4.*:*) # i860-SVR4
  	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
  	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
  	else # Add other i860-SVR4 vendors below as they are discovered.
  	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
  	fi
! 	exit ;;
      mini*:CTIX:SYS*5:*)
  	# "miniframe"
  	echo m68010-convergent-sysv
! 	exit ;;
      mc68k:UNIX:SYSTEM5:3.51m)
  	echo m68k-convergent-sysv
! 	exit ;;
      M680?0:D-NIX:5.3:*)
  	echo m68k-diab-dnix
! 	exit ;;
      M68*:*:R3V[5678]*:*)
! 	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
      3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
  	OS_REL=''
  	test -r /etc/.relid \
  	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
  	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
! 	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
  	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
! 	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
      3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
          /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
!           && { echo i486-ncr-sysv4; exit; } ;;
      m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
  	echo m68k-unknown-lynxos${UNAME_RELEASE}
! 	exit ;;
      mc68030:UNIX_System_V:4.*:*)
  	echo m68k-atari-sysv4
! 	exit ;;
      TSUNAMI:LynxOS:2.*:*)
  	echo sparc-unknown-lynxos${UNAME_RELEASE}
! 	exit ;;
      rs6000:LynxOS:2.*:*)
  	echo rs6000-unknown-lynxos${UNAME_RELEASE}
! 	exit ;;
      PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
  	echo powerpc-unknown-lynxos${UNAME_RELEASE}
! 	exit ;;
      SM[BE]S:UNIX_SV:*:*)
  	echo mips-dde-sysv${UNAME_RELEASE}
! 	exit ;;
      RM*:ReliantUNIX-*:*:*)
  	echo mips-sni-sysv4
! 	exit ;;
      RM*:SINIX-*:*:*)
  	echo mips-sni-sysv4
! 	exit ;;
      *:SINIX-*:*:*)
  	if uname -p 2>/dev/null >/dev/null ; then
  		UNAME_MACHINE=`(uname -p) 2>/dev/null`
***************
*** 1123,1191 ****
  	else
  		echo ns32k-sni-sysv
  	fi
! 	exit 0 ;;
      PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
                        # says <Richard.M.Bartel@ccMail.Census.GOV>
          echo i586-unisys-sysv4
!         exit 0 ;;
      *:UNIX_System_V:4*:FTX*)
  	# From Gerald Hewes <hewes@openmarket.com>.
  	# How about differentiating between stratus architectures? -djm
  	echo hppa1.1-stratus-sysv4
! 	exit 0 ;;
      *:*:*:FTX*)
  	# From seanf@swdc.stratus.com.
  	echo i860-stratus-sysv4
! 	exit 0 ;;
      *:VOS:*:*)
  	# From Paul.Green@stratus.com.
  	echo hppa1.1-stratus-vos
! 	exit 0 ;;
      mc68*:A/UX:*:*)
  	echo m68k-apple-aux${UNAME_RELEASE}
! 	exit 0 ;;
      news*:NEWS-OS:6*:*)
  	echo mips-sony-newsos6
! 	exit 0 ;;
      R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
  	if [ -d /usr/nec ]; then
  	        echo mips-nec-sysv${UNAME_RELEASE}
  	else
  	        echo mips-unknown-sysv${UNAME_RELEASE}
  	fi
!         exit 0 ;;
      BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
  	echo powerpc-be-beos
! 	exit 0 ;;
      BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
  	echo powerpc-apple-beos
! 	exit 0 ;;
      BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
  	echo i586-pc-beos
! 	exit 0 ;;
      SX-4:SUPER-UX:*:*)
  	echo sx4-nec-superux${UNAME_RELEASE}
! 	exit 0 ;;
      SX-5:SUPER-UX:*:*)
  	echo sx5-nec-superux${UNAME_RELEASE}
! 	exit 0 ;;
      SX-6:SUPER-UX:*:*)
  	echo sx6-nec-superux${UNAME_RELEASE}
! 	exit 0 ;;
      Power*:Rhapsody:*:*)
  	echo powerpc-apple-rhapsody${UNAME_RELEASE}
! 	exit 0 ;;
      *:Rhapsody:*:*)
  	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
! 	exit 0 ;;
      *:Darwin:*:*)
  	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
  	case $UNAME_PROCESSOR in
- 	    *86) UNAME_PROCESSOR=i686 ;;
  	    unknown) UNAME_PROCESSOR=powerpc ;;
  	esac
  	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
! 	exit 0 ;;
      *:procnto*:*:* | *:QNX:[0123456789]*:*)
  	UNAME_PROCESSOR=`uname -p`
  	if test "$UNAME_PROCESSOR" = "x86"; then
--- 1123,1194 ----
  	else
  		echo ns32k-sni-sysv
  	fi
! 	exit ;;
      PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
                        # says <Richard.M.Bartel@ccMail.Census.GOV>
          echo i586-unisys-sysv4
!         exit ;;
      *:UNIX_System_V:4*:FTX*)
  	# From Gerald Hewes <hewes@openmarket.com>.
  	# How about differentiating between stratus architectures? -djm
  	echo hppa1.1-stratus-sysv4
! 	exit ;;
      *:*:*:FTX*)
  	# From seanf@swdc.stratus.com.
  	echo i860-stratus-sysv4
! 	exit ;;
!     i*86:VOS:*:*)
! 	# From Paul.Green@stratus.com.
! 	echo ${UNAME_MACHINE}-stratus-vos
! 	exit ;;
      *:VOS:*:*)
  	# From Paul.Green@stratus.com.
  	echo hppa1.1-stratus-vos
! 	exit ;;
      mc68*:A/UX:*:*)
  	echo m68k-apple-aux${UNAME_RELEASE}
! 	exit ;;
      news*:NEWS-OS:6*:*)
  	echo mips-sony-newsos6
! 	exit ;;
      R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
  	if [ -d /usr/nec ]; then
  	        echo mips-nec-sysv${UNAME_RELEASE}
  	else
  	        echo mips-unknown-sysv${UNAME_RELEASE}
  	fi
!         exit ;;
      BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
  	echo powerpc-be-beos
! 	exit ;;
      BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
  	echo powerpc-apple-beos
! 	exit ;;
      BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
  	echo i586-pc-beos
! 	exit ;;
      SX-4:SUPER-UX:*:*)
  	echo sx4-nec-superux${UNAME_RELEASE}
! 	exit ;;
      SX-5:SUPER-UX:*:*)
  	echo sx5-nec-superux${UNAME_RELEASE}
! 	exit ;;
      SX-6:SUPER-UX:*:*)
  	echo sx6-nec-superux${UNAME_RELEASE}
! 	exit ;;
      Power*:Rhapsody:*:*)
  	echo powerpc-apple-rhapsody${UNAME_RELEASE}
! 	exit ;;
      *:Rhapsody:*:*)
  	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
! 	exit ;;
      *:Darwin:*:*)
  	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
  	case $UNAME_PROCESSOR in
  	    unknown) UNAME_PROCESSOR=powerpc ;;
  	esac
  	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
! 	exit ;;
      *:procnto*:*:* | *:QNX:[0123456789]*:*)
  	UNAME_PROCESSOR=`uname -p`
  	if test "$UNAME_PROCESSOR" = "x86"; then
***************
*** 1193,1214 ****
  		UNAME_MACHINE=pc
  	fi
  	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
! 	exit 0 ;;
      *:QNX:*:4*)
  	echo i386-pc-qnx
! 	exit 0 ;;
      NSR-?:NONSTOP_KERNEL:*:*)
  	echo nsr-tandem-nsk${UNAME_RELEASE}
! 	exit 0 ;;
      *:NonStop-UX:*:*)
  	echo mips-compaq-nonstopux
! 	exit 0 ;;
      BS2000:POSIX*:*:*)
  	echo bs2000-siemens-sysv
! 	exit 0 ;;
      DS/*:UNIX_System_V:*:*)
  	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
! 	exit 0 ;;
      *:Plan9:*:*)
  	# "uname -m" is not consistent, so use $cputype instead. 386
  	# is converted to i386 for consistency with other x86
--- 1196,1220 ----
  		UNAME_MACHINE=pc
  	fi
  	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
! 	exit ;;
      *:QNX:*:4*)
  	echo i386-pc-qnx
! 	exit ;;
!     NSE-?:NONSTOP_KERNEL:*:*)
! 	echo nse-tandem-nsk${UNAME_RELEASE}
! 	exit ;;
      NSR-?:NONSTOP_KERNEL:*:*)
  	echo nsr-tandem-nsk${UNAME_RELEASE}
! 	exit ;;
      *:NonStop-UX:*:*)
  	echo mips-compaq-nonstopux
! 	exit ;;
      BS2000:POSIX*:*:*)
  	echo bs2000-siemens-sysv
! 	exit ;;
      DS/*:UNIX_System_V:*:*)
  	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
! 	exit ;;
      *:Plan9:*:*)
  	# "uname -m" is not consistent, so use $cputype instead. 386
  	# is converted to i386 for consistency with other x86
***************
*** 1219,1259 ****
  	    UNAME_MACHINE="$cputype"
  	fi
  	echo ${UNAME_MACHINE}-unknown-plan9
! 	exit 0 ;;
      *:TOPS-10:*:*)
  	echo pdp10-unknown-tops10
! 	exit 0 ;;
      *:TENEX:*:*)
  	echo pdp10-unknown-tenex
! 	exit 0 ;;
      KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
  	echo pdp10-dec-tops20
! 	exit 0 ;;
      XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
  	echo pdp10-xkl-tops20
! 	exit 0 ;;
      *:TOPS-20:*:*)
  	echo pdp10-unknown-tops20
! 	exit 0 ;;
      *:ITS:*:*)
  	echo pdp10-unknown-its
! 	exit 0 ;;
      SEI:*:*:SEIUX)
          echo mips-sei-seiux${UNAME_RELEASE}
! 	exit 0 ;;
      *:DragonFly:*:*)
  	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
! 	exit 0 ;;
      *:*VMS:*:*)
      	UNAME_MACHINE=`(uname -p) 2>/dev/null`
  	case "${UNAME_MACHINE}" in
! 	    A*) echo alpha-dec-vms && exit 0 ;;
! 	    I*) echo ia64-dec-vms && exit 0 ;;
! 	    V*) echo vax-dec-vms && exit 0 ;;
  	esac ;;
      *:XENIX:*:SysV)
  	echo i386-pc-xenix
! 	exit 0 ;;
  esac
  
  #echo '(No uname command or uname output not recognized.)' 1>&2
--- 1225,1268 ----
  	    UNAME_MACHINE="$cputype"
  	fi
  	echo ${UNAME_MACHINE}-unknown-plan9
! 	exit ;;
      *:TOPS-10:*:*)
  	echo pdp10-unknown-tops10
! 	exit ;;
      *:TENEX:*:*)
  	echo pdp10-unknown-tenex
! 	exit ;;
      KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
  	echo pdp10-dec-tops20
! 	exit ;;
      XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
  	echo pdp10-xkl-tops20
! 	exit ;;
      *:TOPS-20:*:*)
  	echo pdp10-unknown-tops20
! 	exit ;;
      *:ITS:*:*)
  	echo pdp10-unknown-its
! 	exit ;;
      SEI:*:*:SEIUX)
          echo mips-sei-seiux${UNAME_RELEASE}
! 	exit ;;
      *:DragonFly:*:*)
  	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
! 	exit ;;
      *:*VMS:*:*)
      	UNAME_MACHINE=`(uname -p) 2>/dev/null`
  	case "${UNAME_MACHINE}" in
! 	    A*) echo alpha-dec-vms ; exit ;;
! 	    I*) echo ia64-dec-vms ; exit ;;
! 	    V*) echo vax-dec-vms ; exit ;;
  	esac ;;
      *:XENIX:*:SysV)
  	echo i386-pc-xenix
! 	exit ;;
!     i*86:skyos:*:*)
! 	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
! 	exit ;;
  esac
  
  #echo '(No uname command or uname output not recognized.)' 1>&2
***************
*** 1285,1291 ****
  #endif
  
  #if defined (__arm) && defined (__acorn) && defined (__unix)
!   printf ("arm-acorn-riscix"); exit (0);
  #endif
  
  #if defined (hp300) && !defined (hpux)
--- 1294,1300 ----
  #endif
  
  #if defined (__arm) && defined (__acorn) && defined (__unix)
!   printf ("arm-acorn-riscix\n"); exit (0);
  #endif
  
  #if defined (hp300) && !defined (hpux)
***************
*** 1374,1384 ****
  }
  EOF
  
! $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && $dummy && exit 0
  
  # Apollos put the system type in the environment.
  
! test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
  
  # Convex versions that predate uname can use getsysinfo(1)
  
--- 1383,1394 ----
  }
  EOF
  
! $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
! 	{ echo "$SYSTEM_NAME"; exit; }
  
  # Apollos put the system type in the environment.
  
! test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
  
  # Convex versions that predate uname can use getsysinfo(1)
  
***************
*** 1387,1408 ****
      case `getsysinfo -f cpu_type` in
      c1*)
  	echo c1-convex-bsd
! 	exit 0 ;;
      c2*)
  	if getsysinfo -f scalar_acc
  	then echo c32-convex-bsd
  	else echo c2-convex-bsd
  	fi
! 	exit 0 ;;
      c34*)
  	echo c34-convex-bsd
! 	exit 0 ;;
      c38*)
  	echo c38-convex-bsd
! 	exit 0 ;;
      c4*)
  	echo c4-convex-bsd
! 	exit 0 ;;
      esac
  fi
  
--- 1397,1418 ----
      case `getsysinfo -f cpu_type` in
      c1*)
  	echo c1-convex-bsd
! 	exit ;;
      c2*)
  	if getsysinfo -f scalar_acc
  	then echo c32-convex-bsd
  	else echo c2-convex-bsd
  	fi
! 	exit ;;
      c34*)
  	echo c34-convex-bsd
! 	exit ;;
      c38*)
  	echo c38-convex-bsd
! 	exit ;;
      c4*)
  	echo c4-convex-bsd
! 	exit ;;
      esac
  fi
  
***************
*** 1413,1419 ****
  the operating system you are using. It is advised that you
  download the most up to date version of the config scripts from
  
!     ftp://ftp.gnu.org/pub/gnu/config/
  
  If the version you run ($0) is already up to date, please
  send the following data and any information you think might be
--- 1423,1431 ----
  the operating system you are using. It is advised that you
  download the most up to date version of the config scripts from
  
!   http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
! and
!   http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
  
  If the version you run ($0) is already up to date, please
  send the following data and any information you think might be
*** ./solenv/inc/startup/UNIX/macros.mk.osr6	Mon Apr 11 01:59:25 2005
--- ./solenv/inc/startup/UNIX/macros.mk	Wed Oct 26 20:22:52 2005
***************
*** 1,7 ****
  # This file is used for all $(OS)==UNX during startup
  #
  
! SHELL *:= /usr/bin/csh
  SHELLFLAGS	 *:=
  GROUPSHELL *:= $(SHELL)
  
--- 1,7 ----
  # This file is used for all $(OS)==UNX during startup
  #
  
! SHELL *:= /usr/bin/tcsh
  SHELLFLAGS	 *:=
  GROUPSHELL *:= $(SHELL)
  
*** ./solenv/inc/startup/UNIX/sysvr1/macros.mk.osr6	Wed Oct 26 20:22:52 2005
--- ./solenv/inc/startup/UNIX/sysvr1/macros.mk	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,6 ----
+ # We hang off the standard sysvr3'isms
+ #
+ __.incdir !:= $(INCFILENAME:d:d:d:d)/sysvr3
+ 
+ # Process environment-specific refinements, if any.
+ .INCLUDE .SETDIR=$(__.incdir) .NOINFER .IGNORE : macros.mk
*** ./solenv/inc/startup/UNIX/sysvr3/gnu/macros.mk.osr6	Wed Oct 26 20:22:52 2005
--- ./solenv/inc/startup/UNIX/sysvr3/gnu/macros.mk	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,12 ----
+ # System V R3 GCC compiler specific macro definitions...
+ #
+ 
+ # Common tool renamings
+ CC    *:= gcc
+ "C++" *:= g++
+ AS    *:= gas
+ YACC  *:= bison
+ LEX   *:= flex
+ 
+ # Common flag settings
+ ARFLAGS *= -rvs
*** ./solenv/inc/startup/UNIX/sysvr3/macros.mk.osr6	Wed Oct 26 20:22:52 2005
--- ./solenv/inc/startup/UNIX/sysvr3/macros.mk	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,7 ----
+ # Define additional UNIX specific macros.
+ #
+ 
+ # Process environment-specific refinements, if any.
+ .IF $(OSENVIRONMENT)
+    .INCLUDE .NOINFER .IGNORE : $(INCFILENAME:d)$(OSENVIRONMENT)$/macros.mk
+ .ENDIF
*** ./solenv/inc/startup/UNIX/sysvr4/macros.mk.osr6	Wed Oct 26 20:22:52 2005
--- ./solenv/inc/startup/UNIX/sysvr4/macros.mk	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,6 ----
+ # We hang off the standard sysvr3'isms
+ #
+ __.incdir !:= $(INCFILENAME:d:d:d:d)/sysvr3
+ 
+ # Process environment-specific refinements, if any.
+ .INCLUDE .SETDIR=$(__.incdir) .NOINFER .IGNORE : macros.mk
*** ./solenv/inc/startup/UNIX/recipes.mk.osr6	Wed Oct 26 20:22:52 2005
--- ./solenv/inc/startup/UNIX/recipes.mk	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,15 ----
+ # Define additional UNIX specific build recipes.
+ #
+ 
+ # Define additional build targets.
+ %$E : %.sh; cp $< $@; chmod 0777 $@
+ 
+ # This rule tells how to make a non-suffixed executable from its single
+ # file source.
+ % : %$O; $(CC) $(LDFLAGS) -o $@ $< $(LDLIBS)
+ 
+ # This rule tells how to make a.out from it's immediate list of prerequisites.
+ %.out :; $(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)
+ 
+ # Process release-specific refinements, if any.
+ .INCLUDE .NOINFER .IGNORE : $(INCFILENAME:d)$(OSRELEASE)$/recipes.mk
*** ./solenv/inc/startup/SCO/macros.mk.osr6	Wed Oct 26 20:22:52 2005
--- ./solenv/inc/startup/SCO/macros.mk	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,2 ----
+ 
+ .INCLUDE .NOINFER .IGNORE : $(INCFILENAME:d:d:d)UNIX$/macros.mk
*** ./solenv/inc/unx.mk.osr6	Thu Sep  8 02:50:55 2005
--- ./solenv/inc/unx.mk	Wed Oct 26 20:22:52 2005
***************
*** 81,86 ****
--- 81,90 ----
  .INCLUDE : unxsogi.mk
  .ENDIF
  
+ .IF "$(COM)$(OS)$(CPU)" == "UDKSCOI"
+ .INCLUDE : unxscoudk.mk
+ .ENDIF
+ 
  .IF "$(COM)$(OS)$(CPU)" == "GCCSCOI"
  .INCLUDE : unxscoi.mk
  .ENDIF
*** ./solenv/inc/unxscoudk.mk.osr6	Wed Oct 26 20:22:52 2005
--- ./solenv/inc/unxscoudk.mk	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,196 ----
+ #*************************************************************************
+ #
+ #   $RCSfile: unxsoli4.mk,v $
+ #
+ #   $Revision: 1.2.18.2 $
+ #
+ #   last change: $Author: hr $ $Date: 2004/01/09 18:59:16 $
+ #
+ #   The Contents of this file are made available subject to the terms of
+ #   either of the following licenses
+ #
+ #          - GNU Lesser General Public License Version 2.1
+ #          - Sun Industry Standards Source License Version 1.1
+ #
+ #   Sun Microsystems Inc., October, 2000
+ #
+ #   GNU Lesser General Public License Version 2.1
+ #   =============================================
+ #   Copyright 2000 by Sun Microsystems, Inc.
+ #   901 San Antonio Road, Palo Alto, CA 94303, USA
+ #
+ #   This library is free software; you can redistribute it and/or
+ #   modify it under the terms of the GNU Lesser General Public
+ #   License version 2.1, as published by the Free Software Foundation.
+ #
+ #   This library is distributed in the hope that it will be useful,
+ #   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ #   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ #   Lesser General Public License for more details.
+ #
+ #   You should have received a copy of the GNU Lesser General Public
+ #   License along with this library; if not, write to the Free Software
+ #   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ #   MA  02111-1307  USA
+ #
+ #
+ #   Sun Industry Standards Source License Version 1.1
+ #   =================================================
+ #   The contents of this file are subject to the Sun Industry Standards
+ #   Source License Version 1.1 (the "License"); You may not use this file
+ #   except in compliance with the License. You may obtain a copy of the
+ #   License at http://www.openoffice.org/license.html.
+ #
+ #   Software provided under this License is provided on an "AS IS" basis,
+ #   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ #   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ #   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ #   See the License for the specific provisions governing your rights and
+ #   obligations concerning the Software.
+ #
+ #   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ #
+ #   Copyright: 2000 by Sun Microsystems, Inc.
+ #
+ #   All Rights Reserved.
+ #
+ #   Contributor(s): _______________________________________
+ #
+ #
+ #
+ #*************************************************************************
+ 
+ 
+ ASM=/usr/ccs/bin/as
+ AFLAGS=-P -q
+ MAKEDEPEND=/usr/X11R6/bin/makedepend
+ 
+ CDEFS+=-D_PTHREADS -DSYSV -DSUN -DSUN4 -D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS -DSTLPORT_VERSION=400
+ 
+ SOLAR_JAVA*=TRUE
+ .IF "$(SOLAR_JAVA)"!=""
+ JAVADEF=-DSOLAR_JAVA
+ JAVAFLAGSDEBUG=-g
+ .IF "$(debug)"==""
+ JAVA_RUNTIME=-ljava
+ .ELSE
+ JAVA_RUNTIME=-ljava_g
+ .ENDIF
+ .ENDIF
+ 
+ CXX*=CC
+ CC*=cc
+ 
+ CFLAGS=$(PREENVCFLAGS) -c $(INCLUDE)
+ CFLAGSCC=
+ CFLAGSCXX=
+ 
+ # flags to enable build with symbols; required for crashdump feature
+ CFLAGSENABLESYMBOLS=
+ 
+ CFLAGSEXCEPTIONS=
+ CFLAGS_NO_EXCEPTIONS=
+ 
+ CFLAGSOBJGUIST=-KPIC
+ CFLAGSOBJCUIST=-KPIC
+ CFLAGSOBJGUIMT=-KPIC
+ CFLAGSOBJCUIMT=-KPIC
+ CFLAGSSLOGUIMT=-KPIC
+ CFLAGSSLOCUIMT=-KPIC
+ CFLAGSPROF=
+ CFLAGSDEBUG=
+ CFLAGSDBGUTIL=
+ CFLAGSOPT=
+ CFLAGSNOOPT=
+ CFLAGSOUTOBJ=-o
+ 
+ # Enable all warnings
+ CFLAGSWALL=+w2
+ # Set default warn level
+ CFLAGSDFLTWARN=
+ 
+ #STDOBJVCL=$(L)$/salmain.o
+ 
+ THREADLIB=
+ LINK=CC
+ 
+ # -z combreloc combines multiple relocation sections. 
+ # Reduces overhead on startup
+ # -norunpath prevents the compiler from recording his own libs in the runpath
+ LINKFLAGSRUNPATH*=
+ LINKFLAGS=
+ 
+ # -z text force fatal error if non PIC code is linked into shared library.
+ # Such code would be expensive on startup
+ LINKFLAGSSHLGUI=-G
+ LINKFLAGSSHLCUI=-G
+ 
+ # switches for dynamic and static linking
+ LINKFLAGSDEFS*=
+ STATIC		= -Wl,-Bstatic
+ DIRECT		= -Wl,-Bexport
+ DYNAMIC		= -Wl,-Bdynamic
+ 
+ LINKFLAGSAPPGUI+=$(DIRECT)
+ LINKFLAGSAPPCUI+=$(DIRECT)
+ LINKFLAGSSHLGUI+=$(DIRECT)
+ LINKFLAGSSHLCUI+=$(DIRECT)
+ 
+ LINKFLAGSTACK=
+ LINKFLAGSPROF=
+ LINKFLAGSDEBUG=
+ LINKFLAGSOPT=
+ LINKVERSIONMAPFLAG=-M
+ 
+ APPLINKSTATIC=$(STATIC)
+ APPLINKSHARED=$(DIRECT)
+ APP_LINKTYPE=
+ 
+ STDOBJGUI=
+ STDSLOGUI=
+ STDOBJCUI=
+ STDSLOCUI=
+ 
+ STDLIBGUIST=$(DYNAMIC) -lm
+ STDLIBCUIST=$(DYNAMIC) -lm
+ STDLIBGUIMT=$(DYNAMIC) -lm
+ STDLIBCUIMT=$(DYNAMIC) -lm
+ STDSHLGUIST=$(DYNAMIC) -lm -lc
+ STDSHLCUIST=$(DYNAMIC) -lm -lc
+ STDSHLGUIMT=$(DYNAMIC) -lm -lc
+ STDSHLCUIMT=$(DYNAMIC) -lm -lc
+ 
+ STDLIBGUIST+=-lX11
+ STDLIBGUIMT+=-lX11
+ STDSHLGUIST+=-lX11
+ STDSHLGUIMT+=-lX11
+ 
+ # @@@ interposer needed for -Bdirect @@@
+ # LIBSALCPPRT*=-z allextract -lsalcpprt -z defaultextract
+ LIBSALCPPRT=
+ 
+ LIBSTLPORT=$(DYNAMIC)
+ LIBSTLPORTST=$(STATIC) $(DYNAMIC)
+ 
+ 
+ LIBMGR=ar
+ LIBFLAGS=r 
+ 
+ IMPLIB=
+ IMPLIBFLAGS=
+ 
+ MAPSYM=
+ MAPSYMFLAGS=
+ 
+ RC=irc
+ RCFLAGS=-fo$@ $(RCFILES)
+ RCLINK=
+ RCLINKFLAGS=
+ RCSETVERSION=
+ 
+ DLLPOSTFIX=si
+ 
+ DLLPRE=lib
+ DLLPOST=.so
+ 
+ LDUMP=
*** ./solenv/inc/tg_compv.mk.osr6	Thu Sep  8 02:42:24 2005
--- ./solenv/inc/tg_compv.mk	Wed Oct 26 20:22:52 2005
***************
*** 66,78 ****
  CFLAGSNUMVERSION_CMD= -version |& cut -d" " -f4-
  .ENDIF
  
  # that's the version known by the specific
  # compiler
  CCVER:=$(shell -$(CXX) $(CFLAGSVERSION_CMD))
  
  # and a computed integer for comparing
  # each point seperated token blown up to 4 digits
! CCNUMVER:=$(shell -$(CXX) $(CFLAGSNUMVERSION_CMD))
  
  .IF "$(COM)"=="MSC"
  .IF "$(CCNUMVER)">="001200000000"
--- 66,85 ----
  CFLAGSNUMVERSION_CMD= -version |& cut -d" " -f4-
  .ENDIF
  
+ .IF "$(COM)"=="UDK"
+ CFLAGSVERSION= -V
+ CFLAGSVERSION_CMD= -V |& cut -d" " -f4- | grep -v Usage | awk ' { print $3 } '
+ CFLAGSNUMVERSION_CMD=
+ .ENDIF
+ 
  # that's the version known by the specific
  # compiler
  CCVER:=$(shell -$(CXX) $(CFLAGSVERSION_CMD))
  
  # and a computed integer for comparing
  # each point seperated token blown up to 4 digits
! #CCNUMVER:=$(shell -$(CXX) $(CFLAGSNUMVERSION_CMD))
! CCNUMVER=00030004000
  
  .IF "$(COM)"=="MSC"
  .IF "$(CCNUMVER)">="001200000000"
***************
*** 126,131 ****
--- 133,143 ----
  COMNAME=MipsPro
  .ENDIF
  
+ .IF "$(COM)"=="UDK"
+ COMID=unixds
+ COMNAME=UDK
+ .ENDIF
+ 
  .IF "$(COMNAME)"==""
  
  # "EXCEPTIONSFILES" get compiled before this, but shouldn't
*** ./soltools/inc/gen_info.hxx.osr6	Thu Sep  8 00:25:12 2005
--- ./soltools/inc/gen_info.hxx	Wed Oct 26 20:22:52 2005
***************
*** 39,44 ****
--- 39,45 ----
  
  #include "simstr.hxx"
  #include <string.h>
+ #include <strings.h>
  
  
  
*** ./soltools/prj/build.lst.osr6	Fri May  6 02:40:22 2005
--- ./soltools/prj/build.lst	Thu Oct 27 00:49:48 2005
***************
*** 1,4 ****
! so  soltools :   stlport NULL
  so	soltools								usr1	-	all	so_usr1 NULL
  so	soltools\inc							get	-	all	so_inc NULL
  so	soltools\ldump							nmake	-	n	so_ldump so_mkdep NULL
--- 1,4 ----
! so  soltools :   NULL
  so	soltools								usr1	-	all	so_usr1 NULL
  so	soltools\inc							get	-	all	so_inc NULL
  so	soltools\ldump							nmake	-	n	so_ldump so_mkdep NULL
*** ./sysui/prj/build.lst.osr6	Tue Jun 21 08:04:22 2005
--- ./sysui/prj/build.lst	Wed Oct 26 20:22:52 2005
***************
*** 1,4 ****
! su	sysui	:	offapi xml2cmp rdbmaker transex3 setup_native NULL
  su	sysui\source\win32\QuickStart		nmake	-	w	su_win32_quickstart NULL
  su	sysui\source\win32\QuickStart\so	nmake	-	w	su_win32_quickstart_so su_win32_quickstart.w NULL
  su	sysui\desktop\icons					nmake	-	w	su_iconsw NULL
--- 1,4 ----
! su	sysui	:	offapi rdbmaker transex3 setup_native NULL
  su	sysui\source\win32\QuickStart		nmake	-	w	su_win32_quickstart NULL
  su	sysui\source\win32\QuickStart\so	nmake	-	w	su_win32_quickstart_so su_win32_quickstart.w NULL
  su	sysui\desktop\icons					nmake	-	w	su_iconsw NULL
*** ./tools/prj/build.lst.osr6	Fri Feb 11 07:49:57 2005
--- ./tools/prj/build.lst	Wed Oct 26 20:22:52 2005
***************
*** 1,4 ****
! tl	tools	:	cppu external offuh vos ZLIB:zlib expat basegfx comphelper NULL
  tl	tools								usr1	-	all	tl_mkout NULL
  tl	tools\bootstrp\isdll				get		-	all	tl_bsisdll NULL
  tl	tools\bootstrp\addexes				get		-	all	tl_bsexes NULL
--- 1,4 ----
! tl	tools	:	cppu external offuh vos ZLIB:zlib basegfx comphelper NULL
  tl	tools								usr1	-	all	tl_mkout NULL
  tl	tools\bootstrp\isdll				get		-	all	tl_bsisdll NULL
  tl	tools\bootstrp\addexes				get		-	all	tl_bsexes NULL
*** ./vcl/prj/build.lst.osr6	Tue Aug 30 02:37:21 2005
--- ./vcl/prj/build.lst	Thu Oct 27 00:28:14 2005
***************
*** 1,4 ****
! vc	vcl	:	BOOST:boost NAS:nas FREETYPE:freetype psprint rsc sot ucbhelper unotools rvpapi icu i18npool unoil ridljar X11_EXTENSIONS:x11_extensions offuh basegfx SNDFILE:sndfile PORTAUDIO:portaudio transex3 NULL
  vc	vcl										usr1	-	all	vc_mkout NULL
  vc	vcl\source\unotypes						nmake	-	all	vc_unot NULL
  vc	vcl\source\glyphs						nmake	-	all	vc_glyphs vc_unot NULL
--- 1,4 ----
! vc	vcl	:	BOOST:boost NAS:nas FREETYPE:freetype psprint rsc sot ucbhelper unotools rvpapi i18npool unoil ridljar X11_EXTENSIONS:x11_extensions offuh basegfx transex3 NULL
  vc	vcl										usr1	-	all	vc_mkout NULL
  vc	vcl\source\unotypes						nmake	-	all	vc_unot NULL
  vc	vcl\source\glyphs						nmake	-	all	vc_glyphs vc_unot NULL
*** ./xml2cmp/prj/build.lst.osr6	Thu Aug  8 09:07:41 2002
--- ./xml2cmp/prj/build.lst	Thu Oct 27 00:50:14 2005
***************
*** 1,4 ****
! xc  xml2cmp : soltools stlport NULL
  xc  xml2cmp                         usr1    -	all	xc_mkout NULL
  xc  xml2cmp\prj                     get -	all	xc_prj NULL
  xc  xml2cmp\source\support                  nmake   -   all	xc_supp NULL
--- 1,4 ----
! xc  xml2cmp : soltools NULL
  xc  xml2cmp                         usr1    -	all	xc_mkout NULL
  xc  xml2cmp\prj                     get -	all	xc_prj NULL
  xc  xml2cmp\source\support                  nmake   -   all	xc_supp NULL
*** ./xmlhelp/prj/build.lst.osr6	Thu Feb 14 05:22:16 2002
--- ./xmlhelp/prj/build.lst	Wed Oct 26 20:22:52 2005
***************
*** 1,4 ****
! xh	xmlhelp	:	ucbhelper XmlSearch sablot jut unoil berkeleydb NULL
  xh	xmlhelp									usr1	-	all	xh_mkout NULL
  xh	xmlhelp\source\helpprovider				nmake	-	all	xh_helpprovider NULL
  xh	xmlhelp\source\treeview					nmake	-	all	xh_treeview NULL
--- 1,4 ----
! xh	xmlhelp	:	ucbhelper XmlSearch sablot jut unoil NULL
  xh	xmlhelp									usr1	-	all	xh_mkout NULL
  xh	xmlhelp\source\helpprovider				nmake	-	all	xh_helpprovider NULL
  xh	xmlhelp\source\treeview					nmake	-	all	xh_treeview NULL
*** ./Build-OSR6.osr6	Wed Oct 26 20:22:52 2005
--- ./Build-OSR6	Thu Oct 27 12:35:00 2005
***************
*** 0 ****
--- 1,230 ----
+ #!/bin/sh
+ 
+ cp ../SCOUDKI*.zip moz/zipped
+ chmod 755 scripts/*
+ 
+ [ -d config_office ] || {
+   echo "Build script must be run from OpenOffice Source root. Exiting."
+   exit 1
+ }
+ 
+ [ -d logs ] || mkdir logs
+ 
+ # Check dependencies and install if necessary
+ # Run this script in SRC_ROOT folder only
+ PATCH_DIR=`pwd`/patches 	# Location where all patches are stored
+ SRC_ROOT=`pwd` 		#actual root where all openoffice source is thr
+ 
+ # test for General Polygon Clipper library
+ #if test -r ${SRC_ROOT}/external/gpc/gpc.c && 
+ #   test -r ${SRC_ROOT}/external/gpc/gpc.h; then
+ #   echo GPC Lib found 
+ #else
+ #  cp -rf ${PATCH_DIR}/gpc ${SRC_ROOT}/external
+ #fi
+ 
+ PATH=/usr/gnu/bin:${PATH}
+ export PATH
+ 
+ # Here is the script that replaces all ':' of the PATH 
+ # with " " space so that we can run loop on it 
+ ####################################### 
+ BPATH=`echo $PATH | sed  's/^:/.:/
+ 			s/::/:.:/g
+ 			s/:$/:./
+ 			s/:/ /g'`;
+ echo $BPATH
+ #######################################
+ export PATCH_DIR SRC_ROOT BPATH PATH
+ 
+ # 'bison --version' may not work on some versions try checking them 
+ # befor extracting version. the correct version will definitely work
+ # checking for bison
+ for bison in $BPATH
+ do
+   if test -x ${bison}/bison; then
+     bison_version=`${bison}/bison --version 2>/dev/null | grep GNU | sed -e 's@^[^0-9]*@@' -e 's@ .*@@' -e 's@,.*@@'`;
+     bison_longver=`echo $bison_version | awk -F. '{ print \$1*1000+\$2}'`
+     #echo "$bison_longver"
+     # Accept Bison 2.0, check wheather later version work or not 
+     # bison newer tham 1.8 or older then 1.7 work 
+     if test $bison_longver -ge 2000; then
+       echo found Bison $bison_version
+       bison=${bison}/bison
+       break
+     fi
+   fi
+   bison=""   # set to null if not found 
+ done
+ 
+ if test -z "$bison"; then
+   echo no bison found checking for m4...
+ fi
+ 
+ # If no bison found, install it
+ if test -z "$bison"; then
+   # check for m4. 
+   for m4 in $BPATH 
+   do
+     if test -x ${m4}/m4; then
+       if eval "${m4}/m4 --version 2> /dev/null"; then
+         m4_version=`${m4}/m4 --version | sed -e 's@^[^0-9]*@@' -e 's@^.* @@'`;
+         m4_longver=`echo $m4_version | awk -F. '{ print \$1*10+\$2}'`     
+         echo found m4-$m4_version
+         echo $m4_longver
+         if test $m4_longver -ge 14; then
+           break                   
+         fi
+       fi
+     fi
+     m4=""  # if no m4 found set it to empty string
+   done
+ fi
+ 
+ #if Both bison and m4 is not installed install them
+ if test "x$bison" = "x" -a "x$m4" = "x"; then
+   echo INSTALLING M4
+   cp -rf ${PATCH_DIR}/m4-1.4.2 /tmp && \
+   cd /tmp/m4-1.4.2 && \
+   ./configure && \
+   make -i install   
+   if test "$?" != "0"; then 
+      echo ERROR Installing m4
+      { (exit 0); exit 0;}
+   fi
+   cd $SRC_ROOT
+   m4=/usr/local/bin/m4 
+ fi
+ 
+ #If m4 is installed then install bison
+ if test "x$bison" = "x" -a "x$m4" != "x"; then
+   echo INSTALLING Bison-2.0
+   cp -rf ${PATCH_DIR}/bison-2.0 /tmp && \
+   cd /tmp/bison-2.0 && \
+   ./configure && \
+   gmake -i install
+   if test "$?" != "0"; then
+   { (exit 0); exit $?;}
+     #bison=/usr/local/bin/bison
+   fi
+ fi
+ cd $SRC_ROOT
+ if test -x /usr/gnu/bin/gmake; then
+   make_version=`/usr/gnu/bin/gmake -v | grep GNU | sed -e 's@^[^0-9]*@@'` 
+   echo GNU make $make_version
+ fi 
+ 
+ #for vant in $BPATH
+ #do
+ #  if test -n "`echo $vant | grep ant`"; then
+ #    ANT_HOME=`echo $vant | sed -e 's@/bin@@'`; 
+ #    break
+ #  fi
+ #  ant=""
+ #done
+ #if test -d "/usr/ant";then 
+ #  ANT_HOME="/usr/ant"
+ #else
+ #  if  test -z "$ANT_HOME"; then
+ #    echo installing ANT
+ #    cd $PATCH_DIR
+ #    cp -r apache-ant-1.6.2 /usr
+ #    ANT_HOME="/usr/apache-ant-1.6.2"
+ #  fi
+ #fi
+ 
+ ANT_HOME="/usr/ant"
+ ANT=$ANT_HOME/bin/ant
+ PATH=${PATH}:${ANT_HOME}/bin
+ export ANT_HOME PATH ANT
+ 
+ JAVA_HOME="/usr/java"
+ GNU_HOME="/usr/gnu"
+ 
+ if [ "$1" = "-g" ]
+ then
+   CC="gcc -D_REENTRANT -D_NEED_STRINGS_H -DOSR6"
+   CXX="g++ -D_REENTRANT -D_NEED_STRINGS_H -DOSR6"
+   CFLAGS="$CFLAGS -Wall"
+ else
+   CC="cc -Kpthread -Kalloca -D_NEED_STRINGS_H -DOSR6"
+   CXX="CC -Kpthread -Kalloca -D_NEED_STRINGS_H -DOSR6"
+ fi
+ 
+ AR=/usr/bin/ar
+ AS=/usr/bin/as
+ LD=/usr/bin/ld
+ INSTALL="/usr/gnu/bin/install"
+ MAKE=/usr/gnu/bin/gmake
+ STRIP=/usr/bin/strip
+ ARFLAGS=-rv
+ MANPATH=/usr/gnu/man:$MANPATH
+ export ANT_HOME JAVA_HOME GNU_HOME MANPATH PATH
+ export AR AS CC CXX LD MAKE STRIP INSTALL
+ export ARFLAGS ASFLAGS CFLAGS CXXFLAGS LDFLAGS
+ 
+ HOST=i586-sco-sysv5
+ CFLAGS="-O2"
+ INSTALL=/usr/gnu/bin/install
+ NM="nm -p"
+ M4=/usr/gnu/bin/m4
+ if [ "$1" = "-g" ]
+ then
+   CC="gcc -D_REENTRANT"
+   CXX="g++ -D_REENTRANT"
+   CFLAGS="$CFLAGS -Wall"
+ else
+   CC="cc -Kpthread -Kalloca"
+   CXX="CC -Kpthread -Kalloca"
+ fi
+ export CC CXX CFLAGS NM M4 INSTALL
+ cd ${SRC_ROOT}/config_office
+ rm -f ../logs/config_office-configure
+ [ -x /usr/gnu/bin/autoconf ] && /usr/gnu/bin/autoconf
+ ./configure 	\
+ 	--with-jdk-home=/usr/java		\
+ 	--with-ant-home=/usr/ant		\
+ 	--with-zip-home=/usr/bin		\
+ 	--with-system-curl			\
+ 	--with-system-nas			\
+ 	--with-system-freetype			\
+ 	--with-system-zlib			\
+ 	--with-system-jpeg			\
+ 	--with-system-expat			\
+ 	--with-system-libxml			\
+ 	--with-system-python			\
+ 	--with-system-db			\
+ 	--with-system-mozilla			\
+ 	--with-stlport4=/usr		\
+ 	--without-gpc				\
+ 	--enable-symbols			\
+ 	--disable-epm				\
+ 	--disable-gnome-vfs			\
+ 	--with-gnu-cp=/usr/gnu/bin/cp		\
+ 	--with-gnu-patch=/usr/gnu/bin/patch	\
+ 	--prefix=/usr --sysconfdir=/etc 	\
+         --host=$HOST --target=$HOST --build=$HOST 2>&1 | tee ../logs/config_office-configure
+ echo $?
+ cd ..
+ 
+ ########This patch is for UnixWare#######################
+ if test "`uname`"=="UnixWare" ; then
+   if test ! -r ${JAVA_HOME}/include/jni_md.h; then 
+     ln ${JAVA_HOME}/include/unixware/jni_md.h ${JAVA_HOME}/include/jni_md.h
+   fi
+   if test ! -r ${JAVA_HOME}/include/jawt_md.h; then
+     ln ${JAVA_HOME}/include/unixware/jawt_md.h ${JAVA_HOME}/include/jawt_md.h
+   fi
+   if  test ! -x /usr/gnu/bin/make; then
+     ln /usr/gnu/bin/gmake /usr/local/bin/make
+   fi
+   if test ! -x /usr/local/bin/perl; then
+     ln /usr/bin/perl /usr/local/bin/perl
+   fi
+ fi
+ ##############################################################
+ 
+ # Invoke the csh script to setup the environment and run dmake
+ rm -f logs/rundmake
+ ./scripts/rundmake 2>&1 | tee logs/rundmake
+ 
*** ./scripts/rundmake.osr6	Wed Oct 26 20:22:52 2005
--- ./scripts/rundmake	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,5 ----
+ #!/usr/bin/tcsh
+ source UnixIntelEnv.Set && \
+ rehash && \
+ ./bootstrap && \
+ dmake/dmake
*** ./scripts/runinstsetup.osr6	Wed Oct 26 20:22:52 2005
--- ./scripts/runinstsetup	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,6 ----
+ #!/usr/bin/tcsh
+ source UnixIntelEnv.Set && \
+ rehash && \
+ ./bootstrap && \
+ cd instsetoo/util && \
+ dmake
*** ./scripts/Mkp.osr6	Wed Oct 26 20:22:52 2005
--- ./scripts/Mkp	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,13 ----
+ #!/bin/sh
+ 
+ T=patches
+ V=1.1.5
+ rm -f $T/OO-$V-osr6.patch
+ touch $T/OO-$V-osr6.patch
+ 
+ find . -name \*\.00 | while read i
+ do
+     F=`echo $i | sed -e "s/\.00//"`
+     [ -f $F ] && /usr/gnu/bin/diff -u $F.00 $F >> $T/OO-$V-osr6.patch
+ done
+ 
*** ./scripts/Prepsetup.osr6	Wed Oct 26 20:22:52 2005
--- ./scripts/Prepsetup	Wed Oct 26 20:22:52 2005
***************
*** 0 ****
--- 1,14 ----
+ #!/bin/sh
+ 
+ [ -d config_office ] || {
+   echo "Prepsetup script must be run from OpenOffice Source root. Exiting."
+   exit 1
+ }
+ 
+ scripts/Mkp
+ [ -f patches/OO-1.1.5-osr6.patch ] || {
+   echo "Missing patches/OO-1.1.5-osr6.patch. Exiting."
+   exit 1
+ }
+ cp patches/OO-1.1.5-osr6.patch ..
+ tar cf - patches | gzip -9 > ../OO-patches.tar.gz
